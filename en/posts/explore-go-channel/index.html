<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入理解 Go Channel 底层实现 | YanHuan's World</title>
<meta name=keywords content="Go,并发编程"><meta name=description content="Channel 是 Go 语言的核心数据结构，也是支撑 Go 高性能并发编程的重要结构。在本篇文章中，我们将从 channel 的设计原理、数据结构、发送数据、接收数据以及关闭 channel 这几个方面进行一些深入的分析，帮助大家更好地理解 channel 的工作原理。"><meta name=author content="YanHuan"><link rel=canonical href=https://yanhuan0802.github.io/en/posts/explore-go-channel/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://yanhuan0802.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yanhuan0802.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yanhuan0802.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yanhuan0802.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yanhuan0802.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yanhuan0802.github.io/en/posts/explore-go-channel/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yanhuan0802.github.io/en/posts/explore-go-channel/"><meta property="og:site_name" content="YanHuan's World"><meta property="og:title" content="深入理解 Go Channel 底层实现"><meta property="og:description" content="Channel 是 Go 语言的核心数据结构，也是支撑 Go 高性能并发编程的重要结构。在本篇文章中，我们将从 channel 的设计原理、数据结构、发送数据、接收数据以及关闭 channel 这几个方面进行一些深入的分析，帮助大家更好地理解 channel 的工作原理。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-14T21:53:50+08:00"><meta property="article:modified_time" content="2023-11-06T23:21:14+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="并发编程"><meta property="og:see_also" content="https://yanhuan0802.github.io/en/posts/go-context/"><meta property="og:see_also" content="https://yanhuan0802.github.io/en/posts/explore-go-array-slice/"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入理解 Go Channel 底层实现"><meta name=twitter:description content="Channel 是 Go 语言的核心数据结构，也是支撑 Go 高性能并发编程的重要结构。在本篇文章中，我们将从 channel 的设计原理、数据结构、发送数据、接收数据以及关闭 channel 这几个方面进行一些深入的分析，帮助大家更好地理解 channel 的工作原理。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yanhuan0802.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"深入理解 Go Channel 底层实现","item":"https://yanhuan0802.github.io/en/posts/explore-go-channel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入理解 Go Channel 底层实现","name":"深入理解 Go Channel 底层实现","description":"Channel 是 Go 语言的核心数据结构，也是支撑 Go 高性能并发编程的重要结构。在本篇文章中，我们将从 channel 的设计原理、数据结构、发送数据、接收数据以及关闭 channel 这几个方面进行一些深入的分析，帮助大家更好地理解 channel 的工作原理。\n","keywords":["Go","并发编程"],"articleBody":"Channel 是 Go 语言的核心数据结构，也是支撑 Go 高性能并发编程的重要结构。在本篇文章中，我们将从 channel 的设计原理、数据结构、发送数据、接收数据以及关闭 channel 这几个方面进行一些深入的分析，帮助大家更好地理解 channel 的工作原理。\n本文源码基于 Go 1.20\nCSP 模型 Go 的并发哲学 Do not communicate by sharing memory; instead, share memory by communicating.\n不要通过共享内存进行通信，而应该通过通信来共享内存。\n这是 Go 的并发哲学，它依赖于 CSP 模型，基于 channel 实现。\nCSP 的全称是 “Communicating Sequential Processes”，这也是 1978 年 ACM 期刊中 Charles Antony Richard Hoare 写的经典同名论文。在文章中，CSP 也是一门自定义的编程语言，该语言描述了并发过程之间的交互作用。\n相对于使用 sync.Mutex 这样的并发原语，虽然大多数锁的问题可以通过 channel 或者传统的锁两种方式之一解决，但是 Go 语言核心团队更加推荐使用 CSP 的方式。\n数据结构 channel 的数据结构源码位于src/runtime/chan.go 中，如下所示：\n// src/runtime/chan.go type hchan struct { qcount uint // 环形缓冲区中的元素个数 dataqsiz uint // 环形缓冲区的 size buf unsafe.Pointer // 指向环形缓冲区的指针（只针对有缓冲的 channel） elemsize uint16 // chan 中元素大小 closed uint32 elemtype *_type // 元素类型 sendx uint // 已发送元素在环形缓冲区中的索引 recvx uint // 已接收元素在环形缓冲区中的索引 recvq waitq // 接收等待队列 sendq waitq // 发送等待队列 lock mutex // runtime 包提供的互斥锁 } 其中，lock 是一个互斥锁，它会保护 hchan 中的所有字段，也是 channel 线程安全的保证。\n等待队列使用双向链表 waitq 表示，链表中的所有元素都是 sudog 结构：\n// src/runtime/chan.go type waitq struct { first *sudog last *sudog } sudog 表示一个在等待队列中的 g . 其中存储了两个分别指向前后的 sudog 指针以构成链表。 g 与同步对象的关系是多对多的，所以一个 g 可以出现在多个等待队列上面，因此一个 g 可能有多个 sudog ，并且多个 g 可能在等待同一个同步对象，因此一个对象可能有许多 sudog . sudog 是从特殊池中分配出来的。 使用acquireSudog() 和 releaseSudog(s *sudog) 分配和释放它们。sudog 中所有字段都受到 hchan.lock 保护。\n// src/runtime/runtime2.go type sudog struct { g *g next *sudog prev *sudog elem unsafe.Pointer // 指向数据（可能指向栈） // 这三个字段永远不会被同时访问 // 对 channel 来说，waitlink 只由 g 使用。 // 对 semaphores 来说，只有在持有 semaRoot 锁的时候才能访问这三个字段。 acquiretime int64 releasetime int64 ticket uint32 // isSelect 表示 g 是否正在参与选择 // g.selectDone 必须进行 CAS 才能在被唤醒的竞争中胜出。 isSelect bool // success 表示 channel c 上的通信是否成功。 // 如果 goroutine 在 channel c 上传了一个值而被唤醒，则为 true； // 如果因为 c 关闭而被唤醒，则为 false。 success bool parent *sudog // semaRoot 二叉树 waitlink *sudog // g.waiting 列表 or semaRoot waittail *sudog // semaRoot c *hchan // channel } 创建 Channel channel 的创建如下所示：\nch := make(chan int) 在编译阶段，编译器会讲上述代码转换成 OMAKE 类型的节点，并且在类型检查阶段将其转换为 OMAKECHAN 类型。\n// src/cmd/compile/internal/typecheck/typecheck.go func typecheck1(n ir.Node, top int) ir.Node { switch n.Op() { default: ir.Dump(\"typecheck\", n) base.Fatalf(\"typecheck %v\", n.Op()) panic(\"unreachable\") // ... case ir.OMAKE: n := n.(*ir.CallExpr) return tcMake(n) // ... } } // src/cmd/compile/internal/typecheck/func.go func tcMake(n *ir.CallExpr) ir.Node { args := n.Args // ... i := 1 var nn ir.Node switch t.Kind() { default: base.Errorf(\"cannot make type %v\", t) n.SetType(nil) return n // ... // channel 类型 case types.TCHAN: l = nil // 带缓冲 channel if i \u003c len(args) { l = args[i] i++ l = Expr(l) l = DefaultLit(l, types.Types[types.TINT]) if l.Type() == nil { n.SetType(nil) return n } if !checkmake(t, \"buffer\", \u0026l) { n.SetType(nil) return n } } else { // 不带缓冲 channel l = ir.NewInt(0) } nn = ir.NewMakeExpr(n.Pos(), ir.OMAKECHAN, l, nil) } if i \u003c len(args) { base.Errorf(\"too many arguments to make(%v)\", t) n.SetType(nil) return n } nn.SetType(t) return nn } OMAKECHAN 类型的节点最终被转换为 调用 runtime.makechan 或runtime.makechan64 函数：\n// src/cmd/compile/internal/walk/expr.go func walkExpr1(n ir.Node, init *ir.Nodes) ir.Node { switch n.Op() { default: ir.Dump(\"walk\", n) base.Fatalf(\"walkExpr: switch 1 unknown op %+v\", n.Op()) panic(\"unreachable\") case ir.OGETG, ir.OGETCALLERPC, ir.OGETCALLERSP: return n // ... case ir.OMAKECHAN: n := n.(*ir.MakeExpr) return walkMakeChan(n, init) // ... } } // src/cmd/compile/internal/walk/builtin.go func walkMakeChan(n *ir.MakeExpr, init *ir.Nodes) ir.Node { fnname := \"makechan64\" argtype := types.Types[types.TINT64] // 类型检查时如果 TIDEAL 大小在 int 范围内。 // 将 TUINT 或 TUINTPTR 转换为 TINT 时出现大小溢出的情况，将在运行时在 makechan 中进行检查。 if size.Type().IsKind(types.TIDEAL) || size.Type().Size() \u003c= types.Types[types.TUINT].Size() { fnname = \"makechan\" argtype = types.Types[types.TINT] } return mkcall1(chanfn(fnname, 1, n.Type()), n.Type(), init, reflectdata.MakeChanRType(base.Pos, n), typecheck.Conv(size, argtype)) } 上述代码中，默认调用makechan64 函数。如果在 make 函数中传入的 channel size 大小在 int 范围内，推荐使用 makechan() 。因为 makechan() 在 32 位的平台上更快，用的内存更少。\n而runtime.makechan64 最终在判断了入参 size 是否在 int 范围之内后，也会转为runtime.makechan() 来执行，所以我们重点关注 runtime.makechan() 即可：\n// src/runtime/chan.go func makechan64(t *chantype, size int64) *hchan { if int64(int(size)) != size { panic(plainError(\"makechan: size out of range\")) } return makechan(t, int(size)) } // src/runtime/chan.go func makechan(t *chantype, size int) *hchan { elem := t.elem // 检查数据项大小不能超过 64KB if elem.size \u003e= 1\u003c\u003c16 { throw(\"makechan: invalid channel element type\") } // 检查对齐 if hchanSize%maxAlign != 0 || elem.align \u003e maxAlign { throw(\"makechan: bad alignment\") } // 缓冲区大小检查 mem, overflow := math.MulUintptr(elem.size, uintptr(size)) // 溢出判断 if overflow || mem \u003e maxAlloc-hchanSize || size \u003c 0 { panic(plainError(\"makechan: size out of range\")) } // ... // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. var c *hchan switch { case mem == 0: // 不存在缓冲区 c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race 竞争检查利用这个地址来进行同步操作 c.buf = c.raceaddr() case elem.ptrdata == 0: // 元素非指针类型 c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // 元素为指针类型 c = new(hchan) c.buf = mallocgc(mem, elem, true) } // 设置属性 c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) // lock 初始化 lockInit(\u0026c.lock, lockRankHchan) return c } makechan() 代码主要的目的就是生成 *hchan 对象。在 switch-case 中有以下三种情况：\n当 channel 缓冲区大小为 0 时，会在堆上为 channel 开辟一段大小为 hchanSize 的内存空间。 当 channel 缓冲区中存储的元素不是指针类型时，会在堆上为当前 channel 和底层数组分配一段大小为 hchanSize + mem 的连续内存空间。 默认情况下，缓冲区元素类型为指针类型，会在堆上分别为 channel 和 缓冲区分配内存空间。 因为 channel 的创建全部调用 mallocgc() 实现，在堆上开辟了内存空间，channel 本身会被 GC 自动回收。完成内存分配之后，统一对 hchan 中的其他字段做初始化。\n发送数据 向 channel 中发送数据常见代码如下所示：\nch \u003c- 1 在编译阶段，编译器会讲上述代码转换成 OSEND 类型的节点，并最终转换为对 runtime.chansend1() 的调用。\n// src/cmd/compile/internal/walk/expr.go func walkExpr1(n ir.Node, init *ir.Nodes) ir.Node { switch n.Op() { default: ir.Dump(\"walk\", n) base.Fatalf(\"walkExpr: switch 1 unknown op %+v\", n.Op()) panic(\"unreachable\") // ... case ir.OSEND: n := n.(*ir.SendStmt) return walkSend(n, init) } // ... } // src/cmd/compile/internal/walk/expr.go func walkSend(n *ir.SendStmt, init *ir.Nodes) ir.Node { n1 := n.Value n1 = typecheck.AssignConv(n1, n.Chan.Type().Elem(), \"chan send\") n1 = walkExpr(n1, init) n1 = typecheck.NodAddr(n1) return mkcall1(chanfn(\"chansend1\", 2, n.Chan.Type()), nil, init, n.Chan, n1) } 而 runtime.chansend1() 只是调用了runtime.chansend()函数，并传入 channel 和需要发送的数据。\n// src/runtime/chan.go func chansend1(c *hchan, elem unsafe.Pointer) { chansend(c, elem, true, getcallerpc()) } 所以 channel 发送数据的核心实现在 runtime.chansend() 函数中，并且根据参数 block 直是否为 true 可知当前发送操作是否为阻塞的。由于runtime.chansend函数实现比较复杂，所以我们将它的代码拆为异常检查、同步发送、异步发送、阻塞发送 4 个部分进行分析。\n1. 异常检查 函数一开始先进行异常检查：\n// src/runtime/chan.go func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { // 是否阻塞 if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\"unreachable\") } if debugChan { print(\"chansend: chan=\", c, \"\\n\") } if raceenabled { racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend)) } // 非阻塞、channel未关闭且队列已满 if !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c) { return false } // 加锁 lock(\u0026c.lock) // channel 已经关闭 if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"send on closed channel\")) } // ... } // src/runtime/chan.go func full(c *hchan) bool { // c.dataqsiz 是不可变的，任何时候都可以安全读取 if c.dataqsiz == 0 { return c.recvq.first == nil } return c.qcount == c.dataqsiz } 如果 channel 被 GC 回收会变为 nil，向一个 nil channel 同步发送数据会发生阻塞，gopark 会引发以 waitReasonChanSendNilChan 为原因的休眠，并且之后抛出 unreachable 的 fatal error. 然后，对非阻塞的发送，要检查 channel 是否未关闭以及channel 是否可以接收数据。其次，在发送数据之前，要对整个 channel 加锁，保证线程安全。并再一次检查 channel 是否关闭，如果关闭则抛出 panic。\n2. 同步发送 如果有正在阻塞等待的接收者，则直接从接收等待队列中取出第一个非空的 sudog ，并且调用send函数直接向其发送数据。\n// src/runtime/chan.go func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { //... if sg := c.recvq.dequeue(); sg != nil { send(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true } //... } send 函数具体实现如下：\n// src/runtime/chan.go func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // ... if sg.elem != nil { sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } 函数执行可以分为 2 个部分：\n调用runtime.sendDirect() 函数，将数据直接复制到接收变量的内存地址上。 调用runtime.goready() 函数将等待接收的阻塞 goroutine 的状态改为 Grunnable ，并且把该 goroutine 放到发送方所在处理器 p 的 runnext 上等待执行，该处理器 p 下一次调度时会立刻唤醒数据的接收方。 其中，goready() 具体实现如下：\n// src/runtime/proc.go func goready(gp *g, traceskip int) { systemstack(func() { ready(gp, traceskip, true) }) } func ready(gp *g, traceskip int, next bool) { // ... // status is Gwaiting or Gscanwaiting, make Grunnable and put on runq casgstatus(gp, _Gwaiting, _Grunnable) runqput(mp.p.ptr(), gp, next) wakep() releasem(mp) } casgstatus()函数的作用是修改当前 goroutine 的状态，runqput 的作用是把接收方 g 绑定到 p 本地可运行的队列中，此处 next 为 true，就是将 g 插入到 runnext 中 ，等待下一次调度就可以立即运行。这样虽然 goroutine 保证了线程安全，但是在读取数据方面会比数组慢一些，也就是说向 channel 中发送数据后并不能立即从接收方获取到。\n3. 异步发送 如果创建的 channel 包含缓冲区，当接受者队列为空并且 channel 缓冲区中的数据没有装满时，就会执行异步发送的逻辑：\n// src/runtime/chan.go func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { //... if c.qcount \u003c c.dataqsiz { qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026c.lock) return true } //... } 这里首先调用chanbuf() 计算下一个可以存储数据的位置，然后调用typedmemmove() 将发送的数据拷贝到缓冲区 buf 中。拷贝完成后，重新计算发送索引 sendx 以及 qcount 的值。这里 buf 是一个环形的数组，所以当 sendx 和 数组大小相等时，sendx 会重新回到数组开始的位置。\n4. 阻塞发送 当没有接受者可以处理 channel 中的数据，并且没有缓冲区或者缓冲区已满时，向 channel 中发送数据会被阻塞，具体执行的代码如下所示：\n// src/runtime/chan.go func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { //... if !block { unlock(\u0026c.lock) return false } gp := getg() // @1 mysg := acquireSudog() // @2 mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // @3 gp.parkingOnChan.Store(true) // @4 gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) // @5 KeepAlive(ep) // @6 // ... } 执行runtime.getg() 获取当前 goroutine 的指针，用于绑定给一个 sudog。 执行runtime.acquireSudog()获取一个 sudog（可能是新建的 sudog，也有可能是从缓存中获取的），并且设置此次发送的数据和状态，比如当前 goroutine 的指针，发送的 channel，是否在 select 中和带发送数据的内存地址等。 将刚刚获取并处理过的 sudog 加入到发送等待队列。 设置一个原子信号，声明当前 goroutine 还停在某个 channel 上面。在 g 状态变更与设 activeStackChans 状态这两个时间点之间的时间窗口进行栈收缩是不安全的，所以需要设置这个原子信号。 调用runtime.gopark()挂起当前 goruntine ，挂起原因为 waitReasonChanSend，阻塞等待 channel。 最后，调用KeepAlive()函数，确保发送的值保持活动状态，直到接收者将其复制出来。sudog有一个指向堆栈对象的指针，但 sudog 不被认为是堆栈追踪器的根。发送的数值是分配在堆上，这样就可以避免被 GC 回收。 chansend 最后的逻辑是当 goroutine 唤醒以后，解除阻塞的状态：\n// src/runtime/chan.go func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { //... if mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u003e 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) if closed { if c.closed == 0 { throw(\"chansend: spurious wakeup\") } panic(plainError(\"send on closed channel\")) } return true } gorountine 被唤醒后，会完成对 channel 的阻塞数据发送，然后进行基本的数据检查，解除 channel 的绑定并调用releaseSudog()函数释放 sudog。\nchansend()函数最后返回 true，表示此次已经成功向 channel 发送了数据。\n5. 小结 对于向 channel 发送数据的代码已经完成分析，下面做一个小结：\n向已经关闭的 channel 中发送数据，会产生 panic。 如果当前 channel 的 recvq 上存在等待的 g，那么会直接将数据发送给当前 g 并且将其设置为下一个要被调度的 g。 如果 channel 存在未满的缓冲区，则直接将数据写入缓冲区 sendx 所在的位置。 如果不满足以上两种情况，则会获取一个 sudog 结构，并设置好其属性，将其加入 channel 的 sendq 等待队列中，挂起当前 goroutine ，等待缓冲区有位置或者有其他 goroutine 从 channel 中接收数据时被调度器唤醒。 发送数据的过程中包含了 2 次会触发 goroutine 调度的时机：\n当接收等待队列存在 sudog 可以直接接收数据时，执行goready() 函数，将接收等待队列的 goruntine 设置处理器的 runnext 属性，将其状态改为 Grunnable ，等待下次调度便立即运行。 当 channel 阻塞时，将自己加入 channel 的 sendq 发送等待队列，并执行 gopark() 函数，阻塞当前 gorountine，让出 cpu 的使用权。 接收数据 从 channel 中接收数据常见代码如下所示：\n// 将结果赋值给变量 v v := \u003c-ch // comma ok 风格 v, ok := \u003c-ch 在编译阶段，编译器会讲上述代码转换成 ORECV 类型的节点。第二种方式在类型检查阶段会被转换为 OAS2RECV 类型。 与上面发送数据源码分析方式类似，如下图所示，这两种类型首先会被转为对runtime.chanrecv1() 和 runtime.chanrecv2()的调用，并且最终转换为对runtime.chanrecv()的调用。\n// src/runtime/chan.go // go:nosplit func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } // go:nosplit func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } 所以 channel 发送数据的核心实现在 runtime.chanrecv() 函数中，并且根据参数 block 直是否为 true 可知当前发送操作是否为阻塞的，同样由于runtime.chanrecv()函数实现比较复杂，所以我们将它的代码拆为异常检查、同步接收、异步接收、阻塞接收 4 个部分进行分析。\n1.异常检查 runtime.chanrevc()函数一开始是进行异常检查：\n// src/runtime/chan.go func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { if debugChan { print(\"chanrecv: chan=\", c, \"\\n\") } if c == nil { if !block { return } // 阻塞模式，挂起等待 gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\"unreachable\") } // Fast path: check for failed non-blocking operation without acquiring the lock. // 非阻塞并且channel为空 if !block \u0026\u0026 empty(c) { if empty(c) { // The channel is irreversibly closed and empty. if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } //... } // src/runtime/chan.go func empty(c *hchan) bool { // c.dataqsiz 是不可变的 if c.dataqsiz == 0 { return atomic.Loadp(unsafe.Pointer(\u0026c.sendq.first)) == nil } return atomic.Loaduint(\u0026c.qcount) == 0 } 如果 channel 被 GC 回收会变为 nil，从一个 nil channel 同步接收数据会发生阻塞，gopark 会引发以 waitReasonChanReceiveNilChan 为原因的休眠，并且之后抛出 unreachable 的 fatal error. 然后，对非阻塞的发送，要检查 channel 是否为空，如果 channel 为空，那么就会清除 ep 中的数据并且立即返回。这里总共检查了两次 empty()，因为第一次检查时， channel 可能还没有关闭，但是第二次检查的时候关闭了，在两次检查之间可能有待接收的数据到达了。所以需要两次 empty() 检查。\n2.同步接收 如果有正在阻塞等待的发送者，则直接从接收等待队列中取出第一个非空的 sudog ，并且调用recv函数直接向其发送数据。\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { lock(\u0026c.lock) if c.closed != 0 { // 已关闭并且没有数据 if c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026c.lock) if ep != nil { // 清除ep指针 typedmemclr(c.elemtype, ep) } return true, false } } else { // 未关闭，send queue中有等待的writer，writer出队，并调用recv函数 // Just found waiting sender with not closed. if sg := c.sendq.dequeue(); sg != nil { recv(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true, true } } } runtime.recv() 函数的逻辑如下所示：\nfunc recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // 不带缓冲区 if c.dataqsiz == 0 { if raceenabled { racesync(c, sg) } if ep != nil { // copy data from sender recvDirect(c.elemtype, sg, ep) } } else { // 带缓冲区 qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) } // copy data from queue to receiver if ep != nil { typedmemmove(c.elemtype, ep, qp) } // copy data from sender to queue // 将 sender 的数据拷贝到这个槽中 typedmemmove(c.elemtype, qp, sg.elem) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } sg.elem = nil gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } 如果ch不带缓冲区的话，直接调用runtimne.recvDirect函数将 writer 的sg.elem数据拷贝到接收方 ep. 如果带缓冲区的话，此时缓冲区肯定满了，那么就从缓冲区队列头部取出数据拷贝至接收方 ep，然后将 writer 的sg.elem数据拷贝到缓冲区中。 最后唤醒 writer（g） 3.异步接收 当 channel 的缓冲区已经包含数据时，从 channel 中接收数据会直接从缓冲区 recv 的索引位置取出数据进行处理：\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // ... if c.qcount \u003e 0 { // Receive directly from queue qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026c.lock) return true, true } // 不阻塞 if !block { unlock(\u0026c.lock) return false, false } // ... } 如果接收数据的内存地址不为空，那么就会使用runtime.touedmemmove() 函数将缓冲区的数据复制到内存中，然后调用runtime.typedmemclr()函数清除队列中的数据，并且挪动 revcx 的指针位置（如果移动到了环形队列的队尾，下标需要回到队头），减少 count 计数器，并且释放掉占有的锁。\n4.阻塞接收 当 channel 的发送队列中不存在等待的 goroutine，并缺缓冲区也没有数据是，从 channel 中接收数据的操作就会进入阻塞接收的阶段：\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // 阻塞且缓冲区中没有数据 // 拿到当前的goroutine gp := getg() // @1 // 获取一个sudog mysg := acquireSudog() // @2 // sudog 关联 mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil // 入队 c.recvq.enqueue(mysg) // @3 // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. gp.parkingOnChan.Store(true) // @4 // 协程挂起，等待唤醒 gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) // @5 } 执行runtime.getg() 获取当前 goroutine 的指针，用于绑定给一个 sudog。 执行runtime.acquireSudog()获取一个 sudog（可能是新建的 sudog，也有可能是从缓存中获取的），并且关联到当前的 guroutine。 将刚刚获取并处理过的 sudog 加入到接收等待队列。 设置一个原子信号，声明当前 goroutine 还停在某个 channel 上面。在 g 状态变更与设 activeStackChans 状态这两个时间点之间的时间窗口进行栈收缩是不安全的，所以需要设置这个原子信号。 调用runtime.gopark()挂起当前 goruntine ，挂起原因为waitReasonChanReceive，阻塞等待 channel。 上面这段代码与 chansend() 中阻塞发送几乎完全一致，区别在于最后一步没有 KeepAlive(ep)。因为等待的 goroutine ep 中是没有数据需要去保活的。\nchanrecv 最后的逻辑是当 goroutine 唤醒以后，解除阻塞的状态：\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { if mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u003e 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil // sudog 解除关联 mysg.c = nil releaseSudog(mysg) return true, success } gorountine 被唤醒后，会完成对 channel 的阻塞数据接收。接收完最后进行基本的参数检查，解除 channel 的绑定并释放 sudog\n5.小结 对于从 channel 中接收数据的代码已经完成分析，下面做一个小结：\n从已经关闭的 channel 中读取数据，会直接返回 channel 中类型的默认零值。 如果当前 channel 的 sendq 上存在等待的 g，那么会将 recvx 索引所在的数据复制到接收变量所在的内存空间，并将 sendq 队列中 goroutine 中的数据复制到缓冲区。 如果 channel 缓冲区中包含数据，则直接读取recvx 索引对应的数据。 如果不满足以上两种情况，则会获取一个 sudog 结构，并设置好其属性，将其加入 channel 的 recvq 等待队列中，挂起当前 goroutine 等待调度器的唤醒。 接收数据的过程中包含了 2 次会触发 goroutine 调度的时机：\n当 channel 为 nil 时，执行gopark() 挂起当前 goroutine 当 channel 缓冲区为空，并且不存在发送者时，channel 发生阻塞，执行 gopark() 将 g 阻塞，让出 cpu 的使用权并等待调度器的调度。 关闭 Channel 关闭 channel 常见代码如下所示：\nclose(ch) 在编译阶段，编译器会讲上述代码转换成 OCLOSE 类型的节点，并且最终转换为对runtime.closechan()函数的调用：\nfunc closechan(c *hchan) { if c == nil { panic(plainError(\"close of nil channel\")) } // 加锁 lock(\u0026c.lock) if c.closed != 0 { // 已经关闭的channel unlock(\u0026c.lock) panic(plainError(\"close of closed channel\")) } if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan)) racerelease(c.raceaddr()) } // 设置关闭标记位 c.closed = 1 // 1. 申明一个存放g的list，用于存放在等待队列中的groutine var glist gList // 2. 获取所有在recvq里面的协程 // release all readers for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // 3. 获取所有在sendq里面的协程 // release all writers (they will panic) for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026c.lock) // Ready all Gs now that we've dropped the channel lock. // 4.唤醒所有的glist中的goroutine for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } } 关闭 channel 的过程主要可以分为以下几个阶段：\n异常检查：当 Channel 是一个 nil 或者是一个已经关闭的 channel 时，会发生 panic。 分别获取 recvq 和 sendq 中的 goroutine，一并放入 glist 队列中。 唤醒 glist 中的所有 goroutine，等待调度器的调度。 参考资料 Communicating sequential processes Go 语言设计与实现 深入 Go 并发原语 — Channel 底层实现 ","wordCount":"7340","inLanguage":"en","datePublished":"2023-05-14T21:53:50+08:00","dateModified":"2023-11-06T23:21:14+08:00","author":{"@type":"Person","name":"YanHuan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yanhuan0802.github.io/en/posts/explore-go-channel/"},"publisher":{"@type":"Organization","name":"YanHuan's World","logo":{"@type":"ImageObject","url":"https://yanhuan0802.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yanhuan0802.github.io/en/ accesskey=h title="YanHuan's World (Alt + H)">YanHuan's World</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yanhuan0802.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://yanhuan0802.github.io/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yanhuan0802.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yanhuan0802.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://yanhuan0802.github.io/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">深入理解 Go Channel 底层实现</h1><div class=post-meta><span title='2023-05-14 21:53:50 +0800 CST'>May 14, 2023</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;7340 words&nbsp;·&nbsp;YanHuan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#csp-模型>CSP 模型</a><ul><li><a href=#go-的并发哲学>Go 的并发哲学</a></li></ul></li><li><a href=#数据结构>数据结构</a></li><li><a href=#创建-channel>创建 Channel</a></li><li><a href=#发送数据>发送数据</a><ul><li><a href=#1-异常检查>1. 异常检查</a></li><li><a href=#2-同步发送>2. 同步发送</a></li><li><a href=#3-异步发送>3. 异步发送</a></li><li><a href=#4-阻塞发送>4. 阻塞发送</a></li><li><a href=#5-小结>5. 小结</a></li></ul></li><li><a href=#接收数据>接收数据</a><ul><li><a href=#1异常检查>1.异常检查</a></li><li><a href=#2同步接收>2.同步接收</a></li><li><a href=#3异步接收>3.异步接收</a></li><li><a href=#4阻塞接收>4.阻塞接收</a></li><li><a href=#5小结>5.小结</a></li></ul></li><li><a href=#关闭-channel>关闭 Channel</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div><div class=post-content><p>Channel 是 Go 语言的核心数据结构，也是支撑 Go 高性能并发编程的重要结构。在本篇文章中，我们将从 channel 的设计原理、数据结构、发送数据、接收数据以及关闭 channel 这几个方面进行一些深入的分析，帮助大家更好地理解 channel 的工作原理。</p><blockquote><p>本文源码基于 Go 1.20</p></blockquote><h2 id=csp-模型>CSP 模型<a hidden class=anchor aria-hidden=true href=#csp-模型>#</a></h2><h3 id=go-的并发哲学>Go 的并发哲学<a hidden class=anchor aria-hidden=true href=#go-的并发哲学>#</a></h3><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><p>不要通过共享内存进行通信，而应该通过通信来共享内存。</p><p>这是 Go 的并发哲学，它依赖于 CSP 模型，基于 channel 实现。</p><p>CSP 的全称是 “Communicating Sequential Processes”，这也是 1978 年 ACM 期刊中 Charles Antony Richard Hoare 写的经典同名论文。在文章中，CSP 也是一门自定义的编程语言，该语言描述了并发过程之间的交互作用。</p><p>相对于使用 sync.Mutex 这样的并发原语，虽然大多数锁的问题可以通过 channel 或者传统的锁两种方式之一解决，但是 Go 语言核心团队更加推荐使用 CSP 的方式。</p><h2 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h2><p>channel 的数据结构源码位于<code>src/runtime/chan.go</code> 中，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> hchan <span style=color:#8be9fd;font-style:italic>struct</span> {  
</span></span><span style=display:flex><span>	qcount   <span style=color:#8be9fd>uint</span>           <span style=color:#6272a4>// 环形缓冲区中的元素个数  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	dataqsiz <span style=color:#8be9fd>uint</span>           <span style=color:#6272a4>// 环形缓冲区的 size   
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	buf      unsafe.Pointer <span style=color:#6272a4>// 指向环形缓冲区的指针（只针对有缓冲的 channel）  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	elemsize <span style=color:#8be9fd>uint16</span>         <span style=color:#6272a4>// chan 中元素大小  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	closed   <span style=color:#8be9fd>uint32</span>  
</span></span><span style=display:flex><span>	elemtype <span style=color:#ff79c6>*</span>_type <span style=color:#6272a4>// 元素类型  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	sendx    <span style=color:#8be9fd>uint</span>   <span style=color:#6272a4>// 已发送元素在环形缓冲区中的索引  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	recvx    <span style=color:#8be9fd>uint</span>   <span style=color:#6272a4>// 已接收元素在环形缓冲区中的索引  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	recvq    waitq  <span style=color:#6272a4>// 接收等待队列  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	sendq    waitq  <span style=color:#6272a4>// 发送等待队列  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>	lock mutex <span style=color:#6272a4>// runtime 包提供的互斥锁  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>其中，lock 是一个互斥锁，它会保护 hchan 中的所有字段，也是 channel 线程安全的保证。</p><p>等待队列使用双向链表 waitq 表示，链表中的所有元素都是 sudog 结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> waitq <span style=color:#8be9fd;font-style:italic>struct</span> {  
</span></span><span style=display:flex><span>	first <span style=color:#ff79c6>*</span>sudog  
</span></span><span style=display:flex><span>	last  <span style=color:#ff79c6>*</span>sudog  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>sudog 表示一个在等待队列中的 g . 其中存储了两个分别指向前后的 sudog 指针以构成链表。 g 与同步对象的关系是多对多的，所以一个 g 可以出现在多个等待队列上面，因此一个 g 可能有多个 sudog ，并且多个 g 可能在等待同一个同步对象，因此一个对象可能有许多 sudog . sudog 是从特殊池中分配出来的。 使用<code>acquireSudog()</code> 和 <code>releaseSudog(s *sudog)</code> 分配和释放它们。sudog 中所有字段都受到 <code>hchan.lock</code> 保护。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/runtime2.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> sudog <span style=color:#8be9fd;font-style:italic>struct</span> {  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    g <span style=color:#ff79c6>*</span>g  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    next <span style=color:#ff79c6>*</span>sudog  
</span></span><span style=display:flex><span>    prev <span style=color:#ff79c6>*</span>sudog  
</span></span><span style=display:flex><span>    elem unsafe.Pointer <span style=color:#6272a4>// 指向数据（可能指向栈）
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 这三个字段永远不会被同时访问
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 对 channel 来说，waitlink 只由 g 使用。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 对 semaphores 来说，只有在持有 semaRoot 锁的时候才能访问这三个字段。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    acquiretime <span style=color:#8be9fd>int64</span>  
</span></span><span style=display:flex><span>    releasetime <span style=color:#8be9fd>int64</span>  
</span></span><span style=display:flex><span>    ticket      <span style=color:#8be9fd>uint32</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// isSelect 表示 g 是否正在参与选择
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// g.selectDone 必须进行 CAS 才能在被唤醒的竞争中胜出。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    isSelect <span style=color:#8be9fd>bool</span> 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// success 表示 channel c 上的通信是否成功。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 如果 goroutine 在 channel c 上传了一个值而被唤醒，则为 true；
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 如果因为 c 关闭而被唤醒，则为 false。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    success <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    parent   <span style=color:#ff79c6>*</span>sudog <span style=color:#6272a4>// semaRoot 二叉树   
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    waitlink <span style=color:#ff79c6>*</span>sudog <span style=color:#6272a4>// g.waiting 列表 or semaRoot  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    waittail <span style=color:#ff79c6>*</span>sudog <span style=color:#6272a4>// semaRoot  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    c        <span style=color:#ff79c6>*</span>hchan <span style=color:#6272a4>// channel  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><h2 id=创建-channel>创建 Channel<a hidden class=anchor aria-hidden=true href=#创建-channel>#</a></h2><p>channel 的创建如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>ch <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>int</span>)
</span></span></code></pre></div><p>在编译阶段，编译器会讲上述代码转换成 OMAKE 类型的节点，并且在类型检查阶段将其转换为 OMAKECHAN 类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/cmd/compile/internal/typecheck/typecheck.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>typecheck1</span>(n ir.Node, top <span style=color:#8be9fd>int</span>) ir.Node {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>switch</span> n.<span style=color:#50fa7b>Op</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>default</span>:  
</span></span><span style=display:flex><span>	  ir.<span style=color:#50fa7b>Dump</span>(<span style=color:#f1fa8c>&#34;typecheck&#34;</span>, n)  
</span></span><span style=display:flex><span>	  base.<span style=color:#50fa7b>Fatalf</span>(<span style=color:#f1fa8c>&#34;typecheck %v&#34;</span>, n.<span style=color:#50fa7b>Op</span>())  
</span></span><span style=display:flex><span>	  <span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;unreachable&#34;</span>)  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>case</span> ir.OMAKE:  
</span></span><span style=display:flex><span>	   n <span style=color:#ff79c6>:=</span> n.(<span style=color:#ff79c6>*</span>ir.CallExpr)  
</span></span><span style=display:flex><span>	   <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>tcMake</span>(n)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/cmd/compile/internal/typecheck/func.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>tcMake</span>(n <span style=color:#ff79c6>*</span>ir.CallExpr) ir.Node {  
</span></span><span style=display:flex><span>	args <span style=color:#ff79c6>:=</span> n.Args  
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>	i <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>1</span>  
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> nn ir.Node  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>switch</span> t.<span style=color:#50fa7b>Kind</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>default</span>:  
</span></span><span style=display:flex><span>	  base.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;cannot make type %v&#34;</span>, t)  
</span></span><span style=display:flex><span>	  n.<span style=color:#50fa7b>SetType</span>(<span style=color:#ff79c6>nil</span>)  
</span></span><span style=display:flex><span>	  <span style=color:#ff79c6>return</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// channel 类型 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>case</span> types.TCHAN:  
</span></span><span style=display:flex><span>	  l = <span style=color:#ff79c6>nil</span>  
</span></span><span style=display:flex><span>	  <span style=color:#6272a4>// 带缓冲 channel
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	  <span style=color:#ff79c6>if</span> i &lt; <span style=color:#8be9fd;font-style:italic>len</span>(args) {  
</span></span><span style=display:flex><span>		 l = args[i]  
</span></span><span style=display:flex><span>		 i<span style=color:#ff79c6>++</span>  
</span></span><span style=display:flex><span>		 l = <span style=color:#50fa7b>Expr</span>(l)  
</span></span><span style=display:flex><span>		 l = <span style=color:#50fa7b>DefaultLit</span>(l, types.Types[types.TINT])  
</span></span><span style=display:flex><span>		 <span style=color:#ff79c6>if</span> l.<span style=color:#50fa7b>Type</span>() <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {  
</span></span><span style=display:flex><span>			n.<span style=color:#50fa7b>SetType</span>(<span style=color:#ff79c6>nil</span>)  
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> n  
</span></span><span style=display:flex><span>		 }  
</span></span><span style=display:flex><span>		 <span style=color:#ff79c6>if</span> !<span style=color:#50fa7b>checkmake</span>(t, <span style=color:#f1fa8c>&#34;buffer&#34;</span>, <span style=color:#ff79c6>&amp;</span>l) {  
</span></span><span style=display:flex><span>			n.<span style=color:#50fa7b>SetType</span>(<span style=color:#ff79c6>nil</span>)  
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> n  
</span></span><span style=display:flex><span>		 }  
</span></span><span style=display:flex><span>	  } <span style=color:#ff79c6>else</span> {  
</span></span><span style=display:flex><span>		 <span style=color:#6272a4>// 不带缓冲 channel
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		 l = ir.<span style=color:#50fa7b>NewInt</span>(<span style=color:#bd93f9>0</span>)  
</span></span><span style=display:flex><span>	  }  
</span></span><span style=display:flex><span>	  nn = ir.<span style=color:#50fa7b>NewMakeExpr</span>(n.<span style=color:#50fa7b>Pos</span>(), ir.OMAKECHAN, l, <span style=color:#ff79c6>nil</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> i &lt; <span style=color:#8be9fd;font-style:italic>len</span>(args) {  
</span></span><span style=display:flex><span>	  base.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;too many arguments to make(%v)&#34;</span>, t)  
</span></span><span style=display:flex><span>	  n.<span style=color:#50fa7b>SetType</span>(<span style=color:#ff79c6>nil</span>)  
</span></span><span style=display:flex><span>	  <span style=color:#ff79c6>return</span> n  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	nn.<span style=color:#50fa7b>SetType</span>(t)  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> nn  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>OMAKECHAN 类型的节点最终被转换为 调用 <code>runtime.makechan</code> 或<code>runtime.makechan64</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/cmd/compile/internal/walk/expr.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>walkExpr1</span>(n ir.Node, init <span style=color:#ff79c6>*</span>ir.Nodes) ir.Node {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>switch</span> n.<span style=color:#50fa7b>Op</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>default</span>:  
</span></span><span style=display:flex><span>	   ir.<span style=color:#50fa7b>Dump</span>(<span style=color:#f1fa8c>&#34;walk&#34;</span>, n)  
</span></span><span style=display:flex><span>	   base.<span style=color:#50fa7b>Fatalf</span>(<span style=color:#f1fa8c>&#34;walkExpr: switch 1 unknown op %+v&#34;</span>, n.<span style=color:#50fa7b>Op</span>())  
</span></span><span style=display:flex><span>	   <span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;unreachable&#34;</span>)  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>case</span> ir.OGETG, ir.OGETCALLERPC, ir.OGETCALLERSP:  
</span></span><span style=display:flex><span>	   <span style=color:#ff79c6>return</span> n
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>case</span> ir.OMAKECHAN:  
</span></span><span style=display:flex><span>	   n <span style=color:#ff79c6>:=</span> n.(<span style=color:#ff79c6>*</span>ir.MakeExpr)  
</span></span><span style=display:flex><span>	   <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>walkMakeChan</span>(n, init)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/cmd/compile/internal/walk/builtin.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>walkMakeChan</span>(n <span style=color:#ff79c6>*</span>ir.MakeExpr, init <span style=color:#ff79c6>*</span>ir.Nodes) ir.Node {  
</span></span><span style=display:flex><span>	fnname <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>&#34;makechan64&#34;</span>  
</span></span><span style=display:flex><span>	argtype <span style=color:#ff79c6>:=</span> types.Types[types.TINT64]  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 类型检查时如果 TIDEAL 大小在 int 范围内。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// 将 TUINT 或 TUINTPTR 转换为 TINT 时出现大小溢出的情况，将在运行时在 makechan 中进行检查。 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> size.<span style=color:#50fa7b>Type</span>().<span style=color:#50fa7b>IsKind</span>(types.TIDEAL) <span style=color:#ff79c6>||</span> size.<span style=color:#50fa7b>Type</span>().<span style=color:#50fa7b>Size</span>() <span style=color:#ff79c6>&lt;=</span> types.Types[types.TUINT].<span style=color:#50fa7b>Size</span>() {  
</span></span><span style=display:flex><span>	  fnname = <span style=color:#f1fa8c>&#34;makechan&#34;</span>  
</span></span><span style=display:flex><span>	  argtype = types.Types[types.TINT]  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>mkcall1</span>(<span style=color:#50fa7b>chanfn</span>(fnname, <span style=color:#bd93f9>1</span>, n.<span style=color:#50fa7b>Type</span>()), n.<span style=color:#50fa7b>Type</span>(), init, reflectdata.<span style=color:#50fa7b>MakeChanRType</span>(base.Pos, n), typecheck.<span style=color:#50fa7b>Conv</span>(size, argtype))  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述代码中，默认调用<code>makechan64</code> 函数。如果在 make 函数中传入的 channel size 大小在 int 范围内，推荐使用 <code>makechan()</code> 。因为 <code>makechan()</code> 在 32 位的平台上更快，用的内存更少。</p><p>而<code>runtime.makechan64</code> 最终在判断了入参 size 是否在 int 范围之内后，也会转为<code>runtime.makechan()</code> 来执行，所以我们重点关注 <code>runtime.makechan()</code> 即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>makechan64</span>(t <span style=color:#ff79c6>*</span>chantype, size <span style=color:#8be9fd>int64</span>) <span style=color:#ff79c6>*</span>hchan {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>int64</span>(<span style=color:#8be9fd;font-style:italic>int</span>(size)) <span style=color:#ff79c6>!=</span> size {  
</span></span><span style=display:flex><span>	  <span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;makechan: size out of range&#34;</span>))  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>makechan</span>(t, <span style=color:#8be9fd;font-style:italic>int</span>(size))  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>makechan</span>(t <span style=color:#ff79c6>*</span>chantype, size <span style=color:#8be9fd>int</span>) <span style=color:#ff79c6>*</span>hchan {  
</span></span><span style=display:flex><span>	elem <span style=color:#ff79c6>:=</span> t.elem  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 检查数据项大小不能超过 64KB 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> elem.size <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>1</span><span style=color:#ff79c6>&lt;&lt;</span><span style=color:#bd93f9>16</span> {  
</span></span><span style=display:flex><span>	   <span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;makechan: invalid channel element type&#34;</span>)  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 检查对齐
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> hchanSize<span style=color:#ff79c6>%</span>maxAlign <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>||</span> elem.align &gt; maxAlign {  
</span></span><span style=display:flex><span>	   <span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;makechan: bad alignment&#34;</span>)  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 缓冲区大小检查
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	mem, overflow <span style=color:#ff79c6>:=</span> math.<span style=color:#50fa7b>MulUintptr</span>(elem.size, <span style=color:#8be9fd;font-style:italic>uintptr</span>(size))
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 溢出判断
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> overflow <span style=color:#ff79c6>||</span> mem &gt; maxAlloc<span style=color:#ff79c6>-</span>hchanSize <span style=color:#ff79c6>||</span> size &lt; <span style=color:#bd93f9>0</span> {  
</span></span><span style=display:flex><span>	   <span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;makechan: size out of range&#34;</span>))  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ... 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd;font-style:italic>var</span> c <span style=color:#ff79c6>*</span>hchan  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>switch</span> {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>case</span> mem <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:  
</span></span><span style=display:flex><span>	  <span style=color:#6272a4>// 不存在缓冲区
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	  c = (<span style=color:#ff79c6>*</span>hchan)(<span style=color:#50fa7b>mallocgc</span>(hchanSize, <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>true</span>))
</span></span><span style=display:flex><span>	  <span style=color:#6272a4>// Race 竞争检查利用这个地址来进行同步操作
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	  c.buf = c.<span style=color:#50fa7b>raceaddr</span>()  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>case</span> elem.ptrdata <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:  
</span></span><span style=display:flex><span>	  <span style=color:#6272a4>// 元素非指针类型  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	  c = (<span style=color:#ff79c6>*</span>hchan)(<span style=color:#50fa7b>mallocgc</span>(hchanSize<span style=color:#ff79c6>+</span>mem, <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>true</span>))  
</span></span><span style=display:flex><span>	  c.buf = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(c), hchanSize)  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>default</span>:  
</span></span><span style=display:flex><span>	  <span style=color:#6272a4>// 元素为指针类型
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	  c = <span style=color:#8be9fd;font-style:italic>new</span>(hchan)  
</span></span><span style=display:flex><span>	  c.buf = <span style=color:#50fa7b>mallocgc</span>(mem, elem, <span style=color:#ff79c6>true</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 设置属性
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	c.elemsize = <span style=color:#8be9fd;font-style:italic>uint16</span>(elem.size)  
</span></span><span style=display:flex><span>	c.elemtype = elem  
</span></span><span style=display:flex><span>	c.dataqsiz = <span style=color:#8be9fd;font-style:italic>uint</span>(size)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// lock 初始化  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>lockInit</span>(<span style=color:#ff79c6>&amp;</span>c.lock, lockRankHchan)  
</span></span><span style=display:flex><span>	 
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> c  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>makechan()</code> 代码主要的目的就是生成 <code>*hchan</code> 对象。在 switch-case 中有以下三种情况：</p><ul><li>当 channel 缓冲区大小为 0 时，会在堆上为 channel 开辟一段大小为 hchanSize 的内存空间。</li><li>当 channel 缓冲区中存储的元素不是指针类型时，会在堆上为当前 channel 和底层数组分配一段大小为 hchanSize + mem 的连续内存空间。</li><li>默认情况下，缓冲区元素类型为指针类型，会在堆上分别为 channel 和 缓冲区分配内存空间。</li></ul><p>因为 channel 的创建全部调用 <code>mallocgc()</code> 实现，在堆上开辟了内存空间，channel 本身会被 GC 自动回收。完成内存分配之后，统一对 hchan 中的其他字段做初始化。</p><h2 id=发送数据>发送数据<a hidden class=anchor aria-hidden=true href=#发送数据>#</a></h2><p>向 channel 中发送数据常见代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ch &lt;- 1
</span></span></code></pre></div><p>在编译阶段，编译器会讲上述代码转换成 OSEND 类型的节点，并最终转换为对 <code>runtime.chansend1()</code> 的调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/cmd/compile/internal/walk/expr.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>walkExpr1</span>(n ir.Node, init <span style=color:#ff79c6>*</span>ir.Nodes) ir.Node {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>switch</span> n.<span style=color:#50fa7b>Op</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>default</span>:  
</span></span><span style=display:flex><span>	  ir.<span style=color:#50fa7b>Dump</span>(<span style=color:#f1fa8c>&#34;walk&#34;</span>, n)  
</span></span><span style=display:flex><span>	  base.<span style=color:#50fa7b>Fatalf</span>(<span style=color:#f1fa8c>&#34;walkExpr: switch 1 unknown op %+v&#34;</span>, n.<span style=color:#50fa7b>Op</span>())  
</span></span><span style=display:flex><span>	  <span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;unreachable&#34;</span>)  
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>case</span> ir.OSEND:  
</span></span><span style=display:flex><span>	  n <span style=color:#ff79c6>:=</span> n.(<span style=color:#ff79c6>*</span>ir.SendStmt)  
</span></span><span style=display:flex><span>	  <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>walkSend</span>(n, init)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/cmd/compile/internal/walk/expr.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>walkSend</span>(n <span style=color:#ff79c6>*</span>ir.SendStmt, init <span style=color:#ff79c6>*</span>ir.Nodes) ir.Node {  
</span></span><span style=display:flex><span>	n1 <span style=color:#ff79c6>:=</span> n.Value  
</span></span><span style=display:flex><span>	n1 = typecheck.<span style=color:#50fa7b>AssignConv</span>(n1, n.Chan.<span style=color:#50fa7b>Type</span>().<span style=color:#50fa7b>Elem</span>(), <span style=color:#f1fa8c>&#34;chan send&#34;</span>)  
</span></span><span style=display:flex><span>	n1 = <span style=color:#50fa7b>walkExpr</span>(n1, init)  
</span></span><span style=display:flex><span>	n1 = typecheck.<span style=color:#50fa7b>NodAddr</span>(n1)  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>mkcall1</span>(<span style=color:#50fa7b>chanfn</span>(<span style=color:#f1fa8c>&#34;chansend1&#34;</span>, <span style=color:#bd93f9>2</span>, n.Chan.<span style=color:#50fa7b>Type</span>()), <span style=color:#ff79c6>nil</span>, init, n.Chan, n1)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而 <code>runtime.chansend1()</code> 只是调用了<code>runtime.chansend()</code>函数，并传入 channel 和需要发送的数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chansend1</span>(c <span style=color:#ff79c6>*</span>hchan, elem unsafe.Pointer) {  
</span></span><span style=display:flex><span>   <span style=color:#50fa7b>chansend</span>(c, elem, <span style=color:#ff79c6>true</span>, <span style=color:#50fa7b>getcallerpc</span>())  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所以 channel 发送数据的核心实现在 <code>runtime.chansend()</code> 函数中，并且根据参数 block 直是否为 true 可知当前发送操作是否为阻塞的。由于<code>runtime.chansend</code>函数实现比较复杂，所以我们将它的代码拆为<strong>异常检查、同步发送、异步发送、阻塞发送</strong> 4 个部分进行分析。</p><h3 id=1-异常检查>1. 异常检查<a hidden class=anchor aria-hidden=true href=#1-异常检查>#</a></h3><p>函数一开始先进行异常检查：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chansend</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>, callerpc <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>bool</span> {  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {  
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 是否阻塞  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> !block {  
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>gopark</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span style=color:#bd93f9>2</span>)  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;unreachable&#34;</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> debugChan {  
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;chansend: chan=&#34;</span>, c, <span style=color:#f1fa8c>&#34;\n&#34;</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> raceenabled {  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>racereadpc</span>(c.<span style=color:#50fa7b>raceaddr</span>(), callerpc, abi.<span style=color:#50fa7b>FuncPCABIInternal</span>(chansend))  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 非阻塞、channel未关闭且队列已满  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> !block <span style=color:#ff79c6>&amp;&amp;</span> c.closed <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#50fa7b>full</span>(c) {  
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 加锁  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>lock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// channel 已经关闭
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> c.closed <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)  
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;send on closed channel&#34;</span>))  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>full</span>(c <span style=color:#ff79c6>*</span>hchan) <span style=color:#8be9fd>bool</span> {  
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// c.dataqsiz 是不可变的，任何时候都可以安全读取 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> c.dataqsiz <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {  
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> c.recvq.first <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span>  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> c.qcount <span style=color:#ff79c6>==</span> c.dataqsiz  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 被 GC 回收会变为 nil，向一个 nil channel 同步发送数据会发生阻塞，gopark 会引发以 <code>waitReasonChanSendNilChan</code> 为原因的休眠，并且之后抛出 <code>unreachable</code> 的 fatal error. 然后，对非阻塞的发送，要检查 channel 是否未关闭以及channel 是否可以接收数据。其次，在发送数据之前，要对整个 channel 加锁，保证线程安全。并再一次检查 channel 是否关闭，如果关闭则抛出 panic。</p><h3 id=2-同步发送>2. 同步发送<a hidden class=anchor aria-hidden=true href=#2-同步发送>#</a></h3><p>如果有正在阻塞等待的接收者，则直接从接收等待队列中取出第一个非空的 sudog ，并且调用<code>send</code>函数直接向其发送数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chansend</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>, callerpc <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span><span style=color:#6272a4>//...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> sg <span style=color:#ff79c6>:=</span> c.recvq.<span style=color:#50fa7b>dequeue</span>(); sg <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>send</span>(c, sg, ep, <span style=color:#8be9fd;font-style:italic>func</span>() { <span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock) }, <span style=color:#bd93f9>3</span>)  
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#6272a4>//...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p><code>send</code> 函数具体实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>send</span>(c <span style=color:#ff79c6>*</span>hchan, sg <span style=color:#ff79c6>*</span>sudog, ep unsafe.Pointer, unlockf <span style=color:#8be9fd;font-style:italic>func</span>(), skip <span style=color:#8be9fd>int</span>) {  
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> sg.elem <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>sendDirect</span>(c.elemtype, sg, ep)  
</span></span><span style=display:flex><span>		sg.elem = <span style=color:#ff79c6>nil</span>  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	gp <span style=color:#ff79c6>:=</span> sg.g  
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>unlockf</span>()  
</span></span><span style=display:flex><span>	gp.param = unsafe.<span style=color:#50fa7b>Pointer</span>(sg)  
</span></span><span style=display:flex><span>	sg.success = <span style=color:#ff79c6>true</span>  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sg.releasetime <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {  
</span></span><span style=display:flex><span>		sg.releasetime = <span style=color:#50fa7b>cputicks</span>()  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>goready</span>(gp, skip<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>函数执行可以分为 2 个部分：</p><ol><li>调用<code>runtime.sendDirect()</code> 函数，将数据直接复制到接收变量的内存地址上。</li><li>调用<code>runtime.goready()</code> 函数将等待接收的阻塞 goroutine 的状态改为 Grunnable ，并且把该 goroutine 放到发送方所在处理器 p 的 runnext 上等待执行，该处理器 p 下一次调度时会立刻唤醒数据的接收方。</li></ol><p>其中，<code>goready()</code> 具体实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/proc.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>goready</span>(gp <span style=color:#ff79c6>*</span>g, traceskip <span style=color:#8be9fd>int</span>) {  
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>systemstack</span>(<span style=color:#8be9fd;font-style:italic>func</span>() {  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>ready</span>(gp, traceskip, <span style=color:#ff79c6>true</span>)  
</span></span><span style=display:flex><span>	})  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>ready</span>(gp <span style=color:#ff79c6>*</span>g, traceskip <span style=color:#8be9fd>int</span>, next <span style=color:#8be9fd>bool</span>) {  
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>casgstatus</span>(gp, _Gwaiting, _Grunnable)  
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>runqput</span>(mp.p.<span style=color:#50fa7b>ptr</span>(), gp, next)  
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>wakep</span>()  
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>releasem</span>(mp)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>casgstatus()</code>函数的作用是修改当前 goroutine 的状态，<code>runqput</code> 的作用是把接收方 g 绑定到 p 本地可运行的队列中，此处 next 为 true，就是将 g 插入到 runnext 中 ，等待下一次调度就可以立即运行。这样虽然 goroutine 保证了线程安全，但是在读取数据方面会比数组慢一些，也就是说向 channel 中发送数据后并不能立即从接收方获取到。</p><h3 id=3-异步发送>3. 异步发送<a hidden class=anchor aria-hidden=true href=#3-异步发送>#</a></h3><p>如果创建的 channel 包含缓冲区，当接受者队列为空并且 channel 缓冲区中的数据没有装满时，就会执行异步发送的逻辑：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chansend</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>, callerpc <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span><span style=color:#6272a4>//...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> c.qcount &lt; c.dataqsiz {  
</span></span><span style=display:flex><span>		qp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>chanbuf</span>(c, c.sendx)  
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {  
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racenotify</span>(c, c.sendx, <span style=color:#ff79c6>nil</span>)  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>typedmemmove</span>(c.elemtype, qp, ep)  
</span></span><span style=display:flex><span>		c.sendx<span style=color:#ff79c6>++</span>  
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> c.sendx <span style=color:#ff79c6>==</span> c.dataqsiz {  
</span></span><span style=display:flex><span>			c.sendx = <span style=color:#bd93f9>0</span>  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>		c.qcount<span style=color:#ff79c6>++</span>  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)  
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#6272a4>//...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>这里首先调用<code>chanbuf()</code> 计算下一个可以存储数据的位置，然后调用<code>typedmemmove()</code> 将发送的数据拷贝到缓冲区 buf 中。拷贝完成后，重新计算发送索引 sendx 以及 qcount 的值。这里 buf 是一个环形的数组，所以当 sendx 和 数组大小相等时，sendx 会重新回到数组开始的位置。</p><h3 id=4-阻塞发送>4. 阻塞发送<a hidden class=anchor aria-hidden=true href=#4-阻塞发送>#</a></h3><p>当没有接受者可以处理 channel 中的数据，并且没有缓冲区或者缓冲区已满时，向 channel 中发送数据会被阻塞，具体执行的代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chansend</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>, callerpc <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span><span style=color:#6272a4>//...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> !block {  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)  
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	gp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getg</span>()  <span style=color:#6272a4>// @1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	mysg <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>acquireSudog</span>() <span style=color:#6272a4>// @2  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	mysg.releasetime = <span style=color:#bd93f9>0</span>  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> t0 <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {  
</span></span><span style=display:flex><span>		mysg.releasetime = <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	mysg.elem = ep  
</span></span><span style=display:flex><span>	mysg.waitlink = <span style=color:#ff79c6>nil</span>  
</span></span><span style=display:flex><span>	mysg.g = gp  
</span></span><span style=display:flex><span>	mysg.isSelect = <span style=color:#ff79c6>false</span>  
</span></span><span style=display:flex><span>	mysg.c = c  
</span></span><span style=display:flex><span>	gp.waiting = mysg  
</span></span><span style=display:flex><span>	gp.param = <span style=color:#ff79c6>nil</span>  
</span></span><span style=display:flex><span>	c.sendq.<span style=color:#50fa7b>enqueue</span>(mysg)  <span style=color:#6272a4>// @3
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span> 
</span></span><span style=display:flex><span>	gp.parkingOnChan.<span style=color:#50fa7b>Store</span>(<span style=color:#ff79c6>true</span>)  <span style=color:#6272a4>// @4
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>gopark</span>(chanparkcommit, unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>c.lock), waitReasonChanSend, traceEvGoBlockSend, <span style=color:#bd93f9>2</span>)  <span style=color:#6272a4>// @5
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>KeepAlive</span>(ep)  <span style=color:#6272a4>// @6
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><ol><li>执行<code>runtime.getg()</code> 获取当前 goroutine 的指针，用于绑定给一个 sudog。</li><li>执行<code>runtime.acquireSudog()</code>获取一个 sudog（可能是新建的 sudog，也有可能是从缓存中获取的），并且设置此次发送的数据和状态，比如当前 goroutine 的指针，发送的 channel，是否在 select 中和带发送数据的内存地址等。</li><li>将刚刚获取并处理过的 sudog 加入到发送等待队列。</li><li>设置一个原子信号，声明当前 goroutine 还停在某个 channel 上面。在 g 状态变更与设 activeStackChans 状态这两个时间点之间的时间窗口进行栈收缩是不安全的，所以需要设置这个原子信号。</li><li>调用<code>runtime.gopark()</code>挂起当前 goruntine ，挂起原因为 waitReasonChanSend，阻塞等待 channel。</li><li>最后，调用<code>KeepAlive()</code>函数，确保发送的值保持活动状态，直到接收者将其复制出来。sudog有一个指向堆栈对象的指针，但 sudog 不被认为是堆栈追踪器的根。发送的数值是分配在堆上，这样就可以避免被 GC 回收。</li></ol><p><code>chansend</code> 最后的逻辑是当 goroutine 唤醒以后，解除阻塞的状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chansend</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>, callerpc <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span><span style=color:#6272a4>//...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> mysg <span style=color:#ff79c6>!=</span> gp.waiting {  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;G waiting list is corrupted&#34;</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	gp.waiting = <span style=color:#ff79c6>nil</span>  
</span></span><span style=display:flex><span>	gp.activeStackChans = <span style=color:#ff79c6>false</span>  
</span></span><span style=display:flex><span>	closed <span style=color:#ff79c6>:=</span> !mysg.success  
</span></span><span style=display:flex><span>	gp.param = <span style=color:#ff79c6>nil</span>  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> mysg.releasetime &gt; <span style=color:#bd93f9>0</span> {  
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>blockevent</span>(mysg.releasetime<span style=color:#ff79c6>-</span>t0, <span style=color:#bd93f9>2</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	mysg.c = <span style=color:#ff79c6>nil</span>  
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>releaseSudog</span>(mysg)  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> closed {  
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> c.closed <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {  
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;chansend: spurious wakeup&#34;</span>)  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;send on closed channel&#34;</span>))  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>gorountine 被唤醒后，会完成对 channel 的阻塞数据发送，然后进行基本的数据检查，解除 channel 的绑定并调用<code>releaseSudog()</code>函数释放 sudog。</p><p><code>chansend()</code>函数最后返回 true，表示此次已经成功向 channel 发送了数据。</p><h3 id=5-小结>5. 小结<a hidden class=anchor aria-hidden=true href=#5-小结>#</a></h3><p>对于向 channel 发送数据的代码已经完成分析，下面做一个小结：</p><ul><li>向已经关闭的 channel 中发送数据，会产生 panic。</li><li>如果当前 channel 的 recvq 上存在等待的 g，那么会直接将数据发送给当前 g 并且将其设置为下一个要被调度的 g。</li><li>如果 channel 存在未满的缓冲区，则直接将数据写入缓冲区 sendx 所在的位置。</li><li>如果不满足以上两种情况，则会获取一个 sudog 结构，并设置好其属性，将其加入 channel 的 sendq 等待队列中，挂起当前 goroutine ，等待缓冲区有位置或者有其他 goroutine 从 channel 中接收数据时被调度器唤醒。</li></ul><p>发送数据的过程中包含了 2 次会触发 goroutine 调度的时机：</p><ul><li>当接收等待队列存在 sudog 可以直接接收数据时，执行<code>goready()</code> 函数，将接收等待队列的 goruntine 设置处理器的 runnext 属性，将其状态改为 Grunnable ，等待下次调度便立即运行。</li><li>当 channel 阻塞时，将自己加入 channel 的 sendq 发送等待队列，并执行 <code>gopark()</code> 函数，阻塞当前 gorountine，让出 cpu 的使用权。</li></ul><h2 id=接收数据>接收数据<a hidden class=anchor aria-hidden=true href=#接收数据>#</a></h2><p>从 channel 中接收数据常见代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// 将结果赋值给变量 v
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>v <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&lt;-</span>ch  
</span></span><span style=display:flex><span><span style=color:#6272a4>// comma ok 风格
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>v, ok <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&lt;-</span>ch
</span></span></code></pre></div><p>在编译阶段，编译器会讲上述代码转换成 ORECV 类型的节点。第二种方式在类型检查阶段会被转换为 OAS2RECV 类型。
与上面发送数据源码分析方式类似，如下图所示，这两种类型首先会被转为对<code>runtime.chanrecv1()</code> 和 <code>runtime.chanrecv2()</code>的调用，并且最终转换为对<code>runtime.chanrecv()</code>的调用。</p><p><img alt=channel-receive-node.png loading=lazy src=/img/channel-receive-node.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// go:nosplit
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chanrecv1</span>(c <span style=color:#ff79c6>*</span>hchan, elem unsafe.Pointer) {
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>chanrecv</span>(c, elem, <span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// go:nosplit
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chanrecv2</span>(c <span style=color:#ff79c6>*</span>hchan, elem unsafe.Pointer) (received <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span>	_, received = <span style=color:#50fa7b>chanrecv</span>(c, elem, <span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所以 channel 发送数据的核心实现在 <code>runtime.chanrecv()</code> 函数中，并且根据参数 block 直是否为 true 可知当前发送操作是否为阻塞的，同样由于<code>runtime.chanrecv()</code>函数实现比较复杂，所以我们将它的代码拆为<strong>异常检查、同步接收、异步接收、阻塞接收</strong> 4 个部分进行分析。</p><h3 id=1异常检查>1.异常检查<a hidden class=anchor aria-hidden=true href=#1异常检查>#</a></h3><p><code>runtime.chanrevc()</code>函数一开始是进行异常检查：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chanrecv</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>) (selected, received <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> debugChan {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;chanrecv: chan=&#34;</span>, c, <span style=color:#f1fa8c>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> !block {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 阻塞模式，挂起等待
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#50fa7b>gopark</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// 非阻塞并且channel为空
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> !block <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#50fa7b>empty</span>(c) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#50fa7b>empty</span>(c) {
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// The channel is irreversibly closed and empty.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>			<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>				<span style=color:#50fa7b>raceacquire</span>(c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#50fa7b>typedmemclr</span>(c.elemtype, ep)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>empty</span>(c <span style=color:#ff79c6>*</span>hchan) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// c.dataqsiz 是不可变的
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> c.dataqsiz <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> atomic.<span style=color:#50fa7b>Loadp</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>c.sendq.first)) <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> atomic.<span style=color:#50fa7b>Loaduint</span>(<span style=color:#ff79c6>&amp;</span>c.qcount) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 被 GC 回收会变为 nil，从一个 nil channel 同步接收数据会发生阻塞，gopark 会引发以 <code>waitReasonChanReceiveNilChan</code> 为原因的休眠，并且之后抛出 <code>unreachable</code> 的 fatal error. 然后，对非阻塞的发送，要检查 channel 是否为空，如果 channel 为空，那么就会清除 ep 中的数据并且立即返回。这里总共检查了两次 empty()，因为第一次检查时， channel 可能还没有关闭，但是第二次检查的时候关闭了，在两次检查之间可能有待接收的数据到达了。所以需要两次 empty() 检查。</p><h3 id=2同步接收>2.同步接收<a hidden class=anchor aria-hidden=true href=#2同步接收>#</a></h3><p>如果有正在阻塞等待的发送者，则直接从接收等待队列中取出第一个非空的 sudog ，并且调用<code>recv</code>函数直接向其发送数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chanrecv</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>) (selected, received <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>lock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.closed <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 已关闭并且没有数据
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> c.qcount <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>				<span style=color:#50fa7b>raceacquire</span>(c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#6272a4>// 清除ep指针
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>				<span style=color:#50fa7b>typedmemclr</span>(c.elemtype, ep)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 未关闭，send queue中有等待的writer，writer出队，并调用recv函数
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// Just found waiting sender with not closed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> sg <span style=color:#ff79c6>:=</span> c.sendq.<span style=color:#50fa7b>dequeue</span>(); sg <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>recv</span>(c, sg, ep, <span style=color:#8be9fd;font-style:italic>func</span>() { <span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock) }, <span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>runtime.recv()</code> 函数的逻辑如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>recv</span>(c <span style=color:#ff79c6>*</span>hchan, sg <span style=color:#ff79c6>*</span>sudog, ep unsafe.Pointer, unlockf <span style=color:#8be9fd;font-style:italic>func</span>(), skip <span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 不带缓冲区
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> c.dataqsiz <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racesync</span>(c, sg)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// copy data from sender
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>			<span style=color:#50fa7b>recvDirect</span>(c.elemtype, sg, ep)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 带缓冲区
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		qp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>chanbuf</span>(c, c.recvx)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racenotify</span>(c, c.recvx, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racenotify</span>(c, c.recvx, sg)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// copy data from queue to receiver
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>typedmemmove</span>(c.elemtype, ep, qp)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// copy data from sender to queue
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// 将 sender 的数据拷贝到这个槽中
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#50fa7b>typedmemmove</span>(c.elemtype, qp, sg.elem)
</span></span><span style=display:flex><span>		c.recvx<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> c.recvx <span style=color:#ff79c6>==</span> c.dataqsiz {
</span></span><span style=display:flex><span>			c.recvx = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		c.sendx = c.recvx <span style=color:#6272a4>// c.sendx = (c.sendx+1) % c.dataqsiz
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	}
</span></span><span style=display:flex><span>	sg.elem = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	gp <span style=color:#ff79c6>:=</span> sg.g
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>unlockf</span>()
</span></span><span style=display:flex><span>	gp.param = unsafe.<span style=color:#50fa7b>Pointer</span>(sg)
</span></span><span style=display:flex><span>	sg.success = <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sg.releasetime <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		sg.releasetime = <span style=color:#50fa7b>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>goready</span>(gp, skip<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>如果ch不带缓冲区的话，直接调用<code>runtimne.recvDirect</code>函数将 writer 的<code>sg.elem</code>数据拷贝到接收方 ep.</li><li>如果带缓冲区的话，此时缓冲区肯定满了，那么就从缓冲区队列头部取出数据拷贝至接收方 ep，然后将 writer 的<code>sg.elem</code>数据拷贝到缓冲区中。</li><li>最后唤醒 <code>writer（g）</code></li></ul><h3 id=3异步接收>3.异步接收<a hidden class=anchor aria-hidden=true href=#3异步接收>#</a></h3><p>当 channel 的缓冲区已经包含数据时，从 channel 中接收数据会直接从缓冲区 recv 的索引位置取出数据进行处理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chanrecv</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>) (selected, received <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span><span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> c.qcount &gt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Receive directly from queue
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		qp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>chanbuf</span>(c, c.recvx)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racenotify</span>(c, c.recvx, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>typedmemmove</span>(c.elemtype, ep, qp)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>typedmemclr</span>(c.elemtype, qp)
</span></span><span style=display:flex><span>		c.recvx<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> c.recvx <span style=color:#ff79c6>==</span> c.dataqsiz {
</span></span><span style=display:flex><span>			c.recvx = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		c.qcount<span style=color:#ff79c6>--</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 不阻塞
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> !block {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>, <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>如果接收数据的内存地址不为空，那么就会使用<code>runtime.touedmemmove()</code> 函数将缓冲区的数据复制到内存中，然后调用<code>runtime.typedmemclr()</code>函数清除队列中的数据，并且挪动 revcx 的指针位置（如果移动到了环形队列的队尾，下标需要回到队头），减少 count 计数器，并且释放掉占有的锁。</p><h3 id=4阻塞接收>4.阻塞接收<a hidden class=anchor aria-hidden=true href=#4阻塞接收>#</a></h3><p>当 channel 的发送队列中不存在等待的 goroutine，并缺缓冲区也没有数据是，从 channel 中接收数据的操作就会进入阻塞接收的阶段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chanrecv</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>) (selected, received <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 阻塞且缓冲区中没有数据
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// 拿到当前的goroutine
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	gp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getg</span>()  <span style=color:#6272a4>// @1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// 获取一个sudog
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	mysg <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>acquireSudog</span>() <span style=color:#6272a4>// @2
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// sudog 关联
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	mysg.releasetime = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> t0 <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		mysg.releasetime = <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// on gp.waiting where copystack can find it.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	mysg.elem = ep
</span></span><span style=display:flex><span>	mysg.waitlink = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	gp.waiting = mysg
</span></span><span style=display:flex><span>	mysg.g = gp
</span></span><span style=display:flex><span>	mysg.isSelect = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	mysg.c = c
</span></span><span style=display:flex><span>	gp.param = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 入队
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	c.recvq.<span style=color:#50fa7b>enqueue</span>(mysg) <span style=color:#6272a4>// @3
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// to park on a channel. The window between when this G&#39;s status
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// stack shrinking.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	gp.parkingOnChan.<span style=color:#50fa7b>Store</span>(<span style=color:#ff79c6>true</span>) <span style=color:#6272a4>// @4
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// 协程挂起，等待唤醒
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>gopark</span>(chanparkcommit, unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span style=color:#bd93f9>2</span>) <span style=color:#6272a4>// @5
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><ol><li>执行<code>runtime.getg()</code> 获取当前 goroutine 的指针，用于绑定给一个 sudog。</li><li>执行<code>runtime.acquireSudog()</code>获取一个 sudog（可能是新建的 sudog，也有可能是从缓存中获取的），并且关联到当前的 guroutine。</li><li>将刚刚获取并处理过的 sudog 加入到接收等待队列。</li><li>设置一个原子信号，声明当前 goroutine 还停在某个 channel 上面。在 g 状态变更与设 activeStackChans 状态这两个时间点之间的时间窗口进行栈收缩是不安全的，所以需要设置这个原子信号。</li><li>调用<code>runtime.gopark()</code>挂起当前 goruntine ，挂起原因为waitReasonChanReceive，阻塞等待 channel。</li></ol><p>上面这段代码与 <code>chansend()</code> 中阻塞发送几乎完全一致，区别在于最后一步没有 <code>KeepAlive(ep)</code>。因为等待的 goroutine ep 中是没有数据需要去保活的。</p><p><code>chanrecv</code> 最后的逻辑是当 goroutine 唤醒以后，解除阻塞的状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chanrecv</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>) (selected, received <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> mysg <span style=color:#ff79c6>!=</span> gp.waiting {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	gp.waiting = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	gp.activeStackChans = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> mysg.releasetime &gt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>blockevent</span>(mysg.releasetime<span style=color:#ff79c6>-</span>t0, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	success <span style=color:#ff79c6>:=</span> mysg.success
</span></span><span style=display:flex><span>	gp.param = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// sudog 解除关联
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	mysg.c = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>releaseSudog</span>(mysg)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, success
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>gorountine 被唤醒后，会完成对 channel 的阻塞数据接收。接收完最后进行基本的参数检查，解除 channel 的绑定并释放 sudog</p><h3 id=5小结>5.小结<a hidden class=anchor aria-hidden=true href=#5小结>#</a></h3><p>对于从 channel 中接收数据的代码已经完成分析，下面做一个小结：</p><ul><li>从已经关闭的 channel 中读取数据，会直接返回 channel 中类型的默认零值。</li><li>如果当前 channel 的 sendq 上存在等待的 g，那么会将 recvx 索引所在的数据复制到接收变量所在的内存空间，并将 sendq 队列中 goroutine 中的数据复制到缓冲区。</li><li>如果 channel 缓冲区中包含数据，则直接读取recvx 索引对应的数据。</li><li>如果不满足以上两种情况，则会获取一个 sudog 结构，并设置好其属性，将其加入 channel 的 recvq 等待队列中，挂起当前 goroutine 等待调度器的唤醒。</li></ul><p>接收数据的过程中包含了 2 次会触发 goroutine 调度的时机：</p><ul><li>当 channel 为 nil 时，执行<code>gopark()</code> 挂起当前 goroutine</li><li>当 channel 缓冲区为空，并且不存在发送者时，channel 发生阻塞，执行 <code>gopark()</code> 将 g 阻塞，让出 cpu 的使用权并等待调度器的调度。</li></ul><h2 id=关闭-channel>关闭 Channel<a hidden class=anchor aria-hidden=true href=#关闭-channel>#</a></h2><p>关闭 channel 常见代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>close</span>(ch)
</span></span></code></pre></div><p>在编译阶段，编译器会讲上述代码转换成 OCLOSE 类型的节点，并且最终转换为对<code>runtime.closechan()</code>函数的调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>closechan</span>(c <span style=color:#ff79c6>*</span>hchan) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;close of nil channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 加锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>lock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.closed <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 已经关闭的channel
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;close of closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>		callerpc <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getcallerpc</span>()
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>racewritepc</span>(c.<span style=color:#50fa7b>raceaddr</span>(), callerpc, abi.<span style=color:#50fa7b>FuncPCABIInternal</span>(closechan))
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>racerelease</span>(c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 设置关闭标记位
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	c.closed = <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 1. 申明一个存放g的list，用于存放在等待队列中的groutine
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd;font-style:italic>var</span> glist gList
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 2. 获取所有在recvq里面的协程
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// release all readers
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> {
</span></span><span style=display:flex><span>		sg <span style=color:#ff79c6>:=</span> c.recvq.<span style=color:#50fa7b>dequeue</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg.elem <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>typedmemclr</span>(c.elemtype, sg.elem)
</span></span><span style=display:flex><span>			sg.elem = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg.releasetime <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			sg.releasetime = <span style=color:#50fa7b>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		gp <span style=color:#ff79c6>:=</span> sg.g
</span></span><span style=display:flex><span>		gp.param = unsafe.<span style=color:#50fa7b>Pointer</span>(sg)
</span></span><span style=display:flex><span>		sg.success = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>raceacquireg</span>(gp, c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		glist.<span style=color:#50fa7b>push</span>(gp)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 3. 获取所有在sendq里面的协程
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// release all writers (they will panic)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> {
</span></span><span style=display:flex><span>		sg <span style=color:#ff79c6>:=</span> c.sendq.<span style=color:#50fa7b>dequeue</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		sg.elem = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg.releasetime <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			sg.releasetime = <span style=color:#50fa7b>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		gp <span style=color:#ff79c6>:=</span> sg.g
</span></span><span style=display:flex><span>		gp.param = unsafe.<span style=color:#50fa7b>Pointer</span>(sg)
</span></span><span style=display:flex><span>		sg.success = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>raceacquireg</span>(gp, c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		glist.<span style=color:#50fa7b>push</span>(gp)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Ready all Gs now that we&#39;ve dropped the channel lock.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// 4.唤醒所有的glist中的goroutine
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> !glist.<span style=color:#50fa7b>empty</span>() {
</span></span><span style=display:flex><span>		gp <span style=color:#ff79c6>:=</span> glist.<span style=color:#50fa7b>pop</span>()
</span></span><span style=display:flex><span>		gp.schedlink = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>goready</span>(gp, <span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>关闭 channel 的过程主要可以分为以下几个阶段：</p><ul><li>异常检查：当 Channel 是一个 nil 或者是一个已经关闭的 channel 时，会发生 panic。</li><li>分别获取 recvq 和 sendq 中的 goroutine，一并放入 glist 队列中。</li><li>唤醒 glist 中的所有 goroutine，等待调度器的调度。</li></ul><hr><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://dl.acm.org/doi/10.1145/359576.359585>Communicating sequential processes</a></li><li><a href=https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>Go 语言设计与实现</a></li><li><a href=https://halfrost.com/go_channel/>深入 Go 并发原语 — Channel 底层实现</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yanhuan0802.github.io/en/tags/go/>Go</a></li><li><a href=https://yanhuan0802.github.io/en/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>并发编程</a></li></ul><nav class=paginav><a class=prev href=https://yanhuan0802.github.io/en/posts/go-context/><span class=title>« Prev</span><br><span>Go Context 那些事儿</span>
</a><a class=next href=https://yanhuan0802.github.io/en/posts/explore-go-array-slice/><span class=title>Next »</span><br><span>深入理解 Go 数组和切片底层实现</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go Channel 底层实现 on x" href="https://x.com/intent/tweet/?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20Channel%20%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fexplore-go-channel%2f&amp;hashtags=Go%2c%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go Channel 底层实现 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fexplore-go-channel%2f&amp;title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20Channel%20%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;summary=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20Channel%20%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;source=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fexplore-go-channel%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go Channel 底层实现 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fexplore-go-channel%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20Channel%20%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go Channel 底层实现 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fexplore-go-channel%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go Channel 底层实现 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20Channel%20%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0%20-%20https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fexplore-go-channel%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go Channel 底层实现 on telegram" href="https://telegram.me/share/url?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20Channel%20%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fexplore-go-channel%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go Channel 底层实现 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20Channel%20%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&u=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fexplore-go-channel%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=yanhuan0802/yanhuan0802.github.io data-repo-id=R_kgDOIDpgTQ data-category=Announcements data-category-id=DIC_kwDOIDpgTc4CSYzO data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://yanhuan0802.github.io/en/>YanHuan's World</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>