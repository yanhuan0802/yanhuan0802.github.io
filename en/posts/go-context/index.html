<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go Context 那些事儿 | YanHuan's World</title><meta name=keywords content="Go,并发编程"><meta name=description content="context 是 Go 语言应用开发常用的并发控制技术，可以用来控制多级的 goroutine，实现 goroutine 之间退出通知、元数据传递等功能。在本篇文章中，我们将从 context 的"><meta name=author content="YanHuan"><link rel=canonical href=https://yanhuan0802.github.io/en/posts/go-context/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yanhuan0802.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yanhuan0802.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yanhuan0802.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yanhuan0802.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yanhuan0802.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go Context 那些事儿"><meta property="og:description" content="context 是 Go 语言应用开发常用的并发控制技术，可以用来控制多级的 goroutine，实现 goroutine 之间退出通知、元数据传递等功能。在本篇文章中，我们将从 context 的"><meta property="og:type" content="article"><meta property="og:url" content="https://yanhuan0802.github.io/en/posts/go-context/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-30T21:55:43+08:00"><meta property="article:modified_time" content="2023-11-06T23:21:14+08:00"><meta property="og:see_also" content="https://yanhuan0802.github.io/en/posts/explore-go-channel/"><meta property="og:see_also" content="https://yanhuan0802.github.io/en/posts/explore-go-array-slice/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Context 那些事儿"><meta name=twitter:description content="context 是 Go 语言应用开发常用的并发控制技术，可以用来控制多级的 goroutine，实现 goroutine 之间退出通知、元数据传递等功能。在本篇文章中，我们将从 context 的"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Go Context 那些事儿","item":"https://yanhuan0802.github.io/en/posts/go-context/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Context 那些事儿","name":"Go Context 那些事儿","description":"context 是 Go 语言应用开发常用的并发控制技术，可以用来控制多级的 goroutine，实现 goroutine 之间退出通知、元数据传递等功能。在本篇文章中，我们将从 context 的","keywords":["Go","并发编程"],"articleBody":"context 是 Go 语言应用开发常用的并发控制技术，可以用来控制多级的 goroutine，实现 goroutine 之间退出通知、元数据传递等功能。在本篇文章中，我们将从 context 的设计实现以及 context 包相关源码进行解读，帮助大家更好地理解和使用 context 包。\n本文源码基于 Go 1.20\n设计原理 什么是 context context 是 Go1.7 开始标准库开始引入的，翻译为中文叫做“上下文”，准确来说它是 goroutine 的上下文，他可以控制一组呈树状结构的 goroutine，每个 goroutine 拥有相同的上下文。\ncontext 实际上只定义了接口，接口定义如下：\n// src/context/context.go type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key any) any } Deadline() 返回完成工作的截止时间，表示上下文应该被取消的时间，和一个标识是否设置截止时间的 bool 值。如果 ok==false 则表示没有设置截至时间，此时的 deadline 为一个 time.Time 的初始值。 Done() 返回一个 channel，该 channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 channel；对于不支持取消的 Context，该方法可能会返回 nil，如 context.Backgroud() Err() 返回 Context 结束的原因，原因由 Context 实现控制。当 context 还未关闭，Err() 返回 nil. 如果 Context 被取消，则返回 context canceled 错误。 如果 Context 因 deadline 关闭，则返回 context deadline exceeded 错误。 Value() 从 Context 中获取键对应的值。如果未设置 key 对应的值则返回 nil，以相同的 key 多次调用则返回相同的结果。 为什么有 context context 可以用来在多个 goroutine 之间传递上下文信息，包括取消信号、超时时间、截止时间以及特定的 key-value 数据。\n在一次实际的 go 服务请求处理中，我们可能会创建多个 goroutine 来进行处理，在某些场景下，父 goroutine 退出后，和它相关联的子 goroutine 的执行都没有意义，所以子 goroutine 也需要快速的退出，此时通过 context 就可以实现这个能力。\n源码解读 context 接口 如上文所示，context 是一个接口，只要实现了 context 接口中声明的所有方法，便实现了 context。\ncanceler 接口 canceler 接口是 context 包中用于取消操作的 context 接口，实现该接口的类型有 *cancelCtx 和 *timerCtx。\ntype canceler interface { cancel(removeFromParent bool, err, cause error) Done() \u003c-chan struct{} } Done() 方法返回一个只读的 channel，可以用于检查上下文是否已被取消。当上下文被取消时，Done 方法返回的 channel 将被关闭，可以使用这个特性来通知相关的 goroutine 停止其工作并返回。\ncontext 实现 emptyCtx context 包中定义了一个空的 context，名为 emptyCtx，这是最简单常用的 context 类型，对 context 接口中所有方法都是空实现，主要功能是用作 context 的根节点。\ntype emptyCtx struct{} func (emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (emptyCtx) Done() \u003c-chan struct{} { return nil } func (emptyCtx) Err() error { return nil } func (emptyCtx) Value(key any) any { return nil } context 包中最常用的方法是 context.Background() 和 context.TODO()，这两个方法分别会返回私有化变量backgroundCtx{} 和 todoCtx{}，这两个变量都是指向 emptyCtx，所以本质上来说两者没有区别，只是在语义上有所不同。\n// context 的默认值，一般情况下其他的 context 应该从它衍生出来 type backgroundCtx struct{ emptyCtx } // 在不确定应该使用哪种 context 时使用 type todoCtx struct{ emptyCtx } func Background() Context { return backgroundCtx{} } func TODO() Context { return todoCtx{} } cancelCtx cancelCtx 是一个用于取消操作的 context，实现了 canceler 接口，并且直接将接口 Context 作为它的一个匿名字段，这样，它就可以被看成一个 Context。\ntype cancelCtx struct { Context mu sync.Mutex // protects following fields done atomic.Value // of chan struct{}, created lazily, closed by first cancel call // 记录由此 context 派生的所有 context children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call cause error // set to non-nil by the first cancel call } cancelCtx 一般由创建函数 context.WithCancel() 函数构建并暴露给用户使用，WithCancel 会返回用于取消该上下文的函数。如果执行返回的取消函数，当前上下文及其子上下文都会被取消，所有的 goroutine 都会同步收到这个取消信号。\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := withCancel(parent) return c, func() { c.cancel(true, Canceled, nil) } } func withCancel(parent Context) *cancelCtx { if parent == nil { panic(\"cannot create context from nil parent\") } c := newCancelCtx(parent) // 构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消 propagateCancel(parent, c) return c } cancel() 方法的实现就是关闭 channel（c.done）来传递取消信息，并且递归地取消它的所有子结点；达到的效果是通过关闭 channel，将取消信号传递给了它的所有子结点。goroutine 接收到取消信号的方式就是 select 语句中的读 c.done 被选中。\nfunc (c *cancelCtx) cancel(removeFromParent bool, err, cause error) { if err == nil { panic(\"context: internal error: missing cancel error\") } if cause == nil { cause = err } c.mu.Lock() if c.err != nil { c.mu.Unlock() return // already canceled } c.err = err c.cause = cause d, _ := c.done.Load().(chan struct{}) if d == nil { c.done.Store(closedchan) } else { close(d) } for child := range c.children { // NOTE: acquiring the child's lock while holding parent's lock. child.cancel(false, err, cause) } c.children = nil c.mu.Unlock() if removeFromParent { removeChild(c.Context, c) } } 如果入参 removeFromParent 为 true，则从父结点从删除自己。\ntimerCtx timerCtx 是一个可以被取消的计时器上下文，它内部通过嵌入 context.cancelCtx 结构体继承了相关的变量和方法，并且通过持有定时器 timer 和截止时间 deadline 来实现定时取消的能力。\ntype timerCtx struct { *cancelCtx timer *time.Timer // Under cancelCtx.mu. deadline time.Time } func (c *timerCtx) Deadline() (deadline time.Time, ok bool) { return c.deadline, true } // cancel 方法： // 1. 调用 cancelCtx 的 cancel 方法，执行 cancel 操作； // 2. 停止持有的定时器 timer， 减少资源浪费 func (c *timerCtx) cancel(removeFromParent bool, err, cause error) { c.cancelCtx.cancel(false, err, cause) if removeFromParent { // Remove this timerCtx from its parent cancelCtx's children. removeChild(c.cancelCtx.Context, c) } c.mu.Lock() if c.timer != nil { c.timer.Stop() c.timer = nil } c.mu.Unlock() } timerCtx 由创建函数 context.WithTimeout() 创建，该函数直接调用了context.WithDeadline()，传入的 deadline 是当前时间加上 timeout 的时间，也就是从现在开始再经过 timeout 时间就算超时。\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { if parent == nil { panic(\"cannot create context from nil parent\") } if cur, ok := parent.Deadline(); ok \u0026\u0026 cur.Before(d) { // The current deadline is already sooner than the new one. return WithCancel(parent) } c := \u0026timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } propagateCancel(parent, c) dur := time.Until(d) if dur \u003c= 0 { c.cancel(true, DeadlineExceeded, nil) // deadline has already passed return c, func() { c.cancel(false, Canceled, nil) } } c.mu.Lock() defer c.mu.Unlock() if c.err == nil { c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded, nil) }) } return c, func() { c.cancel(true, Canceled, nil) } } valueCtx valueCtx 就是在 context 的基础上加了一个键值对，用于在各级 goroutine 之间传递数据。\ntype valueCtx struct { Context key, val any } valueCtx 由创建函数 context.WithValue() 创建：\nfunc WithValue(parent Context, key, val any) Context { if parent == nil { panic(\"cannot create context from nil parent\") } if key == nil { panic(\"nil key\") } if !reflectlite.TypeOf(key).Comparable() { panic(\"key is not comparable\") } return \u0026valueCtx{parent, key, val} } valueCtx 不需要 cancel 和 deadline，所以只实现 Value 方法即可，如果在当前 context 中 key 值不匹配，就会从父上下文中查找该 key 对应的 value 值，直到返回 nil 或者查找到对应的值。\nfunc (c *valueCtx) Value(key any) any { if c.key == key { return c.val } return value(c.Context, key) } 参考资料 context pkg Go Context 详解之终极无惑 Go 专家编程 通过实例理解 Go 标准库 context 包 ","wordCount":"2240","inLanguage":"en","datePublished":"2023-06-30T21:55:43+08:00","dateModified":"2023-11-06T23:21:14+08:00","author":{"@type":"Person","name":"YanHuan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yanhuan0802.github.io/en/posts/go-context/"},"publisher":{"@type":"Organization","name":"YanHuan's World","logo":{"@type":"ImageObject","url":"https://yanhuan0802.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yanhuan0802.github.io/en/ accesskey=h title="YanHuan's World (Alt + H)">YanHuan's World</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yanhuan0802.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://yanhuan0802.github.io/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yanhuan0802.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yanhuan0802.github.io/en/>Home</a></div><h1 class=post-title>Go Context 那些事儿</h1><div class=post-meta><span title='2023-06-30 21:55:43 +0800 CST'>June 30, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2240 words&nbsp;·&nbsp;YanHuan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#设计原理>设计原理</a><ul><li><a href=#什么是-context>什么是 context</a></li><li><a href=#为什么有-context>为什么有 context</a></li></ul></li><li><a href=#源码解读>源码解读</a><ul><li><a href=#context-接口>context 接口</a></li><li><a href=#canceler-接口>canceler 接口</a></li><li><a href=#context-实现>context 实现</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div><div class=post-content><p>context 是 Go 语言应用开发常用的并发控制技术，可以用来控制多级的 goroutine，实现 goroutine 之间退出通知、元数据传递等功能。在本篇文章中，我们将从 context 的设计实现以及 context 包相关源码进行解读，帮助大家更好地理解和使用 context 包。</p><blockquote><p>本文源码基于 Go 1.20</p></blockquote><h2 id=设计原理>设计原理<a hidden class=anchor aria-hidden=true href=#设计原理>#</a></h2><h3 id=什么是-context>什么是 context<a hidden class=anchor aria-hidden=true href=#什么是-context>#</a></h3><p>context 是 Go1.7 开始标准库开始引入的，翻译为中文叫做“上下文”，准确来说它是 goroutine 的上下文，他可以控制一组呈树状结构的 goroutine，每个 goroutine 拥有相同的上下文。</p><p>context 实际上只定义了接口，接口定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/context/context.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> Context <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Deadline</span>() (deadline time.Time, ok <span style=color:#8be9fd>bool</span>)
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Done</span>() <span style=color:#ff79c6>&lt;-</span><span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd;font-style:italic>struct</span>{}
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Err</span>() <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Value</span>(key any) any
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>Deadline()</code> 返回完成工作的截止时间，表示上下文应该被取消的时间，和一个标识是否设置截止时间的 bool 值。如果 <code>ok==false</code> 则表示没有设置截至时间，此时的 <code>deadline</code> 为一个 <code>time.Time</code> 的初始值。</li><li><code>Done()</code> 返回一个 channel，该 channel 会在当前工作完成或者上下文被取消后关闭，多次调用 <code>Done</code> 方法会返回同一个 channel；对于不支持取消的 Context，该方法可能会返回 nil，如 <code>context.Backgroud()</code></li><li><code>Err()</code> 返回 Context 结束的原因，原因由 Context 实现控制。当 context 还未关闭，<code>Err()</code> 返回 nil.<ul><li>如果 Context 被取消，则返回 <code>context canceled</code> 错误。</li><li>如果 Context 因 deadline 关闭，则返回 <code>context deadline exceeded</code> 错误。</li></ul></li><li><code>Value()</code> 从 Context 中获取键对应的值。如果未设置 key 对应的值则返回 nil，以相同的 key 多次调用则返回相同的结果。</li></ul><h3 id=为什么有-context>为什么有 context<a hidden class=anchor aria-hidden=true href=#为什么有-context>#</a></h3><p>context 可以用来在多个 goroutine 之间传递上下文信息，包括取消信号、超时时间、截止时间以及特定的 key-value 数据。</p><p><img loading=lazy src=/img/context-goroutine.png alt=context-goroutine.png></p><p>在一次实际的 go 服务请求处理中，我们可能会创建多个 goroutine 来进行处理，在某些场景下，父 goroutine 退出后，和它相关联的子 goroutine 的执行都没有意义，所以子 goroutine 也需要快速的退出，此时通过 context 就可以实现这个能力。</p><h2 id=源码解读>源码解读<a hidden class=anchor aria-hidden=true href=#源码解读>#</a></h2><h3 id=context-接口>context 接口<a hidden class=anchor aria-hidden=true href=#context-接口>#</a></h3><p>如上文所示，context 是一个接口，只要实现了 context 接口中声明的所有方法，便实现了 context。</p><h3 id=canceler-接口>canceler 接口<a hidden class=anchor aria-hidden=true href=#canceler-接口>#</a></h3><p>canceler 接口是 context 包中用于取消操作的 context 接口，实现该接口的类型有 <code>*cancelCtx</code> 和 <code>*timerCtx</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> canceler <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>cancel</span>(removeFromParent <span style=color:#8be9fd>bool</span>, err, cause <span style=color:#8be9fd>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>Done</span>() <span style=color:#ff79c6>&lt;-</span><span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd;font-style:italic>struct</span>{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Done()</code> 方法返回一个只读的 channel，可以用于检查上下文是否已被取消。当上下文被取消时，Done 方法返回的 channel 将被关闭，可以使用这个特性来通知相关的 goroutine 停止其工作并返回。</p><h3 id=context-实现>context 实现<a hidden class=anchor aria-hidden=true href=#context-实现>#</a></h3><h4 id=emptyctx>emptyCtx<a hidden class=anchor aria-hidden=true href=#emptyctx>#</a></h4><p>context 包中定义了一个空的 context，名为 <code>emptyCtx</code>，这是最简单常用的 context 类型，对 context 接口中所有方法都是空实现，主要功能是用作 context 的根节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> emptyCtx <span style=color:#8be9fd;font-style:italic>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (emptyCtx) <span style=color:#50fa7b>Deadline</span>() (deadline time.Time, ok <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (emptyCtx) <span style=color:#50fa7b>Done</span>() <span style=color:#ff79c6>&lt;-</span><span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd;font-style:italic>struct</span>{} {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (emptyCtx) <span style=color:#50fa7b>Err</span>() <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (emptyCtx) <span style=color:#50fa7b>Value</span>(key any) any {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>context 包中最常用的方法是 <code>context.Background()</code> 和 <code>context.TODO()</code>，这两个方法分别会返回私有化变量<code>backgroundCtx{}</code> 和 <code>todoCtx{}</code>，这两个变量都是指向 <code>emptyCtx</code>，所以本质上来说两者没有区别，只是在语义上有所不同。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// context 的默认值，一般情况下其他的 context 应该从它衍生出来
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> backgroundCtx <span style=color:#8be9fd;font-style:italic>struct</span>{ emptyCtx }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 在不确定应该使用哪种 context 时使用
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> todoCtx <span style=color:#8be9fd;font-style:italic>struct</span>{ emptyCtx }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>Background</span>() Context {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> backgroundCtx{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>TODO</span>() Context {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> todoCtx{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=cancelctx>cancelCtx<a hidden class=anchor aria-hidden=true href=#cancelctx>#</a></h4><p>cancelCtx 是一个用于取消操作的 context，实现了 canceler 接口，并且直接将接口 Context 作为它的一个匿名字段，这样，它就可以被看成一个 Context。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> cancelCtx <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    Context
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mu       sync.Mutex            <span style=color:#6272a4>// protects following fields
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    done     atomic.Value          <span style=color:#6272a4>// of chan struct{}, created lazily, closed by first cancel call
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 记录由此 context 派生的所有 context
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    children <span style=color:#8be9fd;font-style:italic>map</span>[canceler]<span style=color:#8be9fd;font-style:italic>struct</span>{} <span style=color:#6272a4>// set to nil by the first cancel call
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    err      <span style=color:#8be9fd>error</span>                 <span style=color:#6272a4>// set to non-nil by the first cancel call
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    cause    <span style=color:#8be9fd>error</span>                 <span style=color:#6272a4>// set to non-nil by the first cancel call
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>cancelCtx 一般由创建函数 <code>context.WithCancel()</code> 函数构建并暴露给用户使用，WithCancel 会返回用于取消该上下文的函数。如果执行返回的取消函数，当前上下文及其子上下文都会被取消，所有的 goroutine 都会同步收到这个取消信号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>WithCancel</span>(parent Context) (ctx Context, cancel CancelFunc) {
</span></span><span style=display:flex><span>	c <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>withCancel</span>(parent)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> c, <span style=color:#8be9fd;font-style:italic>func</span>() { c.<span style=color:#50fa7b>cancel</span>(<span style=color:#ff79c6>true</span>, Canceled, <span style=color:#ff79c6>nil</span>) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>withCancel</span>(parent Context) <span style=color:#ff79c6>*</span>cancelCtx {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> parent <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;cannot create context from nil parent&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	c <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>newCancelCtx</span>(parent)
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>propagateCancel</span>(parent, c)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> c
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>cancel()</code> 方法的实现就是关闭 channel（c.done）来传递取消信息，并且递归地取消它的所有子结点；达到的效果是通过关闭 channel，将取消信号传递给了它的所有子结点。goroutine 接收到取消信号的方式就是 select 语句中的读 c.done 被选中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (c <span style=color:#ff79c6>*</span>cancelCtx) <span style=color:#50fa7b>cancel</span>(removeFromParent <span style=color:#8be9fd>bool</span>, err, cause <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;context: internal error: missing cancel error&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> cause <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		cause = err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	c.mu.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		c.mu.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#6272a4>// already canceled
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	}
</span></span><span style=display:flex><span>	c.err = err
</span></span><span style=display:flex><span>	c.cause = cause
</span></span><span style=display:flex><span>	d, _ <span style=color:#ff79c6>:=</span> c.done.<span style=color:#50fa7b>Load</span>().(<span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd;font-style:italic>struct</span>{})
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> d <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		c.done.<span style=color:#50fa7b>Store</span>(closedchan)
</span></span><span style=display:flex><span>	} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>close</span>(d)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> child <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> c.children {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		child.<span style=color:#50fa7b>cancel</span>(<span style=color:#ff79c6>false</span>, err, cause)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	c.children = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	c.mu.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> removeFromParent {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>removeChild</span>(c.Context, c)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果入参 <code>removeFromParent</code> 为 true，则从父结点从删除自己。</p><h4 id=timerctx>timerCtx<a hidden class=anchor aria-hidden=true href=#timerctx>#</a></h4><p>timerCtx 是一个可以被取消的计时器上下文，它内部通过嵌入 <code>context.cancelCtx</code> 结构体继承了相关的变量和方法，并且通过持有定时器 timer 和截止时间 deadline 来实现定时取消的能力。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> timerCtx <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>*</span>cancelCtx
</span></span><span style=display:flex><span>	timer <span style=color:#ff79c6>*</span>time.Timer <span style=color:#6272a4>// Under cancelCtx.mu.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>	deadline time.Time
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (c <span style=color:#ff79c6>*</span>timerCtx) <span style=color:#50fa7b>Deadline</span>() (deadline time.Time, ok <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> c.deadline, <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// cancel 方法：
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 1. 调用 cancelCtx 的 cancel 方法，执行 cancel 操作；
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 2. 停止持有的定时器 timer， 减少资源浪费
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (c <span style=color:#ff79c6>*</span>timerCtx) <span style=color:#50fa7b>cancel</span>(removeFromParent <span style=color:#8be9fd>bool</span>, err, cause <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	c.cancelCtx.<span style=color:#50fa7b>cancel</span>(<span style=color:#ff79c6>false</span>, err, cause)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> removeFromParent {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Remove this timerCtx from its parent cancelCtx&#39;s children.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#50fa7b>removeChild</span>(c.cancelCtx.Context, c)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	c.mu.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.timer <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		c.timer.<span style=color:#50fa7b>Stop</span>()
</span></span><span style=display:flex><span>		c.timer = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	c.mu.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>timerCtx 由创建函数 <code>context.WithTimeout()</code> 创建，该函数直接调用了<code>context.WithDeadline()</code>，传入的 deadline 是当前时间加上 timeout 的时间，也就是从现在开始再经过 timeout 时间就算超时。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>WithTimeout</span>(parent Context, timeout time.Duration) (Context, CancelFunc) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>WithDeadline</span>(parent, time.<span style=color:#50fa7b>Now</span>().<span style=color:#50fa7b>Add</span>(timeout))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>WithDeadline</span>(parent Context, d time.Time) (Context, CancelFunc) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> parent <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;cannot create context from nil parent&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> cur, ok <span style=color:#ff79c6>:=</span> parent.<span style=color:#50fa7b>Deadline</span>(); ok <span style=color:#ff79c6>&amp;&amp;</span> cur.<span style=color:#50fa7b>Before</span>(d) {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// The current deadline is already sooner than the new one.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>WithCancel</span>(parent)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	c <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>timerCtx{
</span></span><span style=display:flex><span>		cancelCtx: <span style=color:#50fa7b>newCancelCtx</span>(parent),
</span></span><span style=display:flex><span>		deadline:  d,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>propagateCancel</span>(parent, c)
</span></span><span style=display:flex><span>	dur <span style=color:#ff79c6>:=</span> time.<span style=color:#50fa7b>Until</span>(d)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> dur <span style=color:#ff79c6>&lt;=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		c.<span style=color:#50fa7b>cancel</span>(<span style=color:#ff79c6>true</span>, DeadlineExceeded, <span style=color:#ff79c6>nil</span>) <span style=color:#6272a4>// deadline has already passed
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>return</span> c, <span style=color:#8be9fd;font-style:italic>func</span>() { c.<span style=color:#50fa7b>cancel</span>(<span style=color:#ff79c6>false</span>, Canceled, <span style=color:#ff79c6>nil</span>) }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	c.mu.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> c.mu.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.err <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		c.timer = time.<span style=color:#50fa7b>AfterFunc</span>(dur, <span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>			c.<span style=color:#50fa7b>cancel</span>(<span style=color:#ff79c6>true</span>, DeadlineExceeded, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> c, <span style=color:#8be9fd;font-style:italic>func</span>() { c.<span style=color:#50fa7b>cancel</span>(<span style=color:#ff79c6>true</span>, Canceled, <span style=color:#ff79c6>nil</span>) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=valuectx>valueCtx<a hidden class=anchor aria-hidden=true href=#valuectx>#</a></h4><p>valueCtx 就是在 context 的基础上加了一个键值对，用于在各级 goroutine 之间传递数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> valueCtx <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	Context
</span></span><span style=display:flex><span>	key, val any
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>valueCtx 由创建函数 <code>context.WithValue()</code> 创建：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>WithValue</span>(parent Context, key, val any) Context {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> parent <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;cannot create context from nil parent&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> key <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;nil key&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !reflectlite.<span style=color:#50fa7b>TypeOf</span>(key).<span style=color:#50fa7b>Comparable</span>() {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#f1fa8c>&#34;key is not comparable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>&amp;</span>valueCtx{parent, key, val}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>valueCtx 不需要 cancel 和 deadline，所以只实现 Value 方法即可，如果在当前 context 中 key 值不匹配，就会从父上下文中查找该 key 对应的 value 值，直到返回 nil 或者查找到对应的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (c <span style=color:#ff79c6>*</span>valueCtx) <span style=color:#50fa7b>Value</span>(key any) any {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.key <span style=color:#ff79c6>==</span> key {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> c.val
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>value</span>(c.Context, key)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://pkg.go.dev/context>context pkg</a></li><li><a href=https://cloud.tencent.com/developer/article/1996581>Go Context 详解之终极无惑</a></li><li><a href=https://github.com/RainbowMango/GoExpertProgramming>Go 专家编程</a></li><li><a href=https://tonybai.com/2022/11/08/understand-go-context-by-example/>通过实例理解 Go 标准库 context 包</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yanhuan0802.github.io/en/tags/go/>Go</a></li><li><a href=https://yanhuan0802.github.io/en/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>并发编程</a></li></ul><nav class=paginav><a class=next href=https://yanhuan0802.github.io/en/posts/explore-go-channel/><span class=title>Next »</span><br><span>深入理解 Go Channel 底层实现</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go Context 那些事儿 on twitter" href="https://twitter.com/intent/tweet/?text=Go%20Context%20%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fgo-context%2f&amp;hashtags=Go%2c%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Context 那些事儿 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fgo-context%2f&amp;title=Go%20Context%20%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&amp;summary=Go%20Context%20%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&amp;source=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fgo-context%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Context 那些事儿 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fgo-context%2f&title=Go%20Context%20%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Context 那些事儿 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fgo-context%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Context 那些事儿 on whatsapp" href="https://api.whatsapp.com/send?text=Go%20Context%20%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fgo-context%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Context 那些事儿 on telegram" href="https://telegram.me/share/url?text=Go%20Context%20%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fen%2fposts%2fgo-context%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://giscus.app/client.js data-repo=yanhuan0802/yanhuan0802.github.io data-repo-id=R_kgDOIDpgTQ data-category=Announcements data-category-id=DIC_kwDOIDpgTc4CSYzO data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://yanhuan0802.github.io/en/>YanHuan's World</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>