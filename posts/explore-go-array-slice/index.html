<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入理解 Go 数组和切片底层实现 | YanHuan's World</title><meta name=keywords content="Go"><meta name=description content="数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。
数组 数据结构 数组是计算机科学中的一种数据结构，它具有以下几个特点：
元素类型相同，存储宽度一致 存储在一段连续的内存空间 空间大小固定，不能修改（会出现数据溢出问题） 可以通过元素索引计算出元素的存储地址 几乎所有的计算机语言，对于数组的实现都是相似的，都拥有上述特性，Go语言也一样。
不同于 C 语言或其他语言，Go 语言数组是值类型，定义的时候就需要指定大小，数组大小是它类型的一部分，不同大小的数组相当于不同的类型，赋值和函数传参都会复制整个数组，相当于是原数组的拷贝。
初始化 数组有两种初始化的方式，一种是显示声明数组的长度，一种是使用[...]T声明数组。
arr1 := [3]int{0, 1, 2} arr2 := [...]int{0, 1, 2} 第二种初始化的方式属于 Go 语言提供的语法糖，在编译期间就会推导出数组的长度，最终转换成第一种，所以上述两种声明方式在运行期间得到的结果是相同的。
在编译期间，Go 会根据数组的元素数量，做出如下的优化：
当元素小于等于4个时，会直接将数组的元素在栈上面初始化； 当元素大于4个时，会将数组在静态区初始化然后复制到栈上面。 缺点 数组大小是固定的，但是很多场景中我们无法直接给出数组的确定长度。
数组是值类型，传递一个很大的数组给函数会消耗很多内存。
切片 由于数组的固定长度和值传递不够灵活，所以 Go 语言中，拥有不定长度的引用类型切片（slice）更加常用。
切片是对数组一个连续片段的引用，这些片段可以是整个数组，或者是由其实和终止索引表示的一些项的子集。
数据结构 切片的数据结构在源码包中定义
// go 1.20 src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 其中，array表示指向相关数组的指针，len表示切片长度，cap表示当前切片的容量，即底层数组的大小。其中底层数组是可以被多个 slice 同时指向的，所以对一个 slice 中的元素进行操作，可能也会影响到其他slice."><meta name=author content="Yan Huan"><link rel=canonical href=https://yanhuan0802.github.io/posts/explore-go-array-slice/><link crossorigin=anonymous href=/assets/css/stylesheet.b183800e2cfbb62c3bce2b2ba56cdb2dd33af76c75cf4550173d5dfebd7c68a6.css integrity="sha256-sYOADiz7tiw7zisrpWzbLdM692x1z0VQFz1d/r18aKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yanhuan0802.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yanhuan0802.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yanhuan0802.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yanhuan0802.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yanhuan0802.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="深入理解 Go 数组和切片底层实现"><meta property="og:description" content="数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。
数组 数据结构 数组是计算机科学中的一种数据结构，它具有以下几个特点：
元素类型相同，存储宽度一致 存储在一段连续的内存空间 空间大小固定，不能修改（会出现数据溢出问题） 可以通过元素索引计算出元素的存储地址 几乎所有的计算机语言，对于数组的实现都是相似的，都拥有上述特性，Go语言也一样。
不同于 C 语言或其他语言，Go 语言数组是值类型，定义的时候就需要指定大小，数组大小是它类型的一部分，不同大小的数组相当于不同的类型，赋值和函数传参都会复制整个数组，相当于是原数组的拷贝。
初始化 数组有两种初始化的方式，一种是显示声明数组的长度，一种是使用[...]T声明数组。
arr1 := [3]int{0, 1, 2} arr2 := [...]int{0, 1, 2} 第二种初始化的方式属于 Go 语言提供的语法糖，在编译期间就会推导出数组的长度，最终转换成第一种，所以上述两种声明方式在运行期间得到的结果是相同的。
在编译期间，Go 会根据数组的元素数量，做出如下的优化：
当元素小于等于4个时，会直接将数组的元素在栈上面初始化； 当元素大于4个时，会将数组在静态区初始化然后复制到栈上面。 缺点 数组大小是固定的，但是很多场景中我们无法直接给出数组的确定长度。
数组是值类型，传递一个很大的数组给函数会消耗很多内存。
切片 由于数组的固定长度和值传递不够灵活，所以 Go 语言中，拥有不定长度的引用类型切片（slice）更加常用。
切片是对数组一个连续片段的引用，这些片段可以是整个数组，或者是由其实和终止索引表示的一些项的子集。
数据结构 切片的数据结构在源码包中定义
// go 1.20 src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 其中，array表示指向相关数组的指针，len表示切片长度，cap表示当前切片的容量，即底层数组的大小。其中底层数组是可以被多个 slice 同时指向的，所以对一个 slice 中的元素进行操作，可能也会影响到其他slice."><meta property="og:type" content="article"><meta property="og:url" content="https://yanhuan0802.github.io/posts/explore-go-array-slice/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-22T20:33:06+08:00"><meta property="article:modified_time" content="2023-04-23T16:31:53+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入理解 Go 数组和切片底层实现"><meta name=twitter:description content="数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。
数组 数据结构 数组是计算机科学中的一种数据结构，它具有以下几个特点：
元素类型相同，存储宽度一致 存储在一段连续的内存空间 空间大小固定，不能修改（会出现数据溢出问题） 可以通过元素索引计算出元素的存储地址 几乎所有的计算机语言，对于数组的实现都是相似的，都拥有上述特性，Go语言也一样。
不同于 C 语言或其他语言，Go 语言数组是值类型，定义的时候就需要指定大小，数组大小是它类型的一部分，不同大小的数组相当于不同的类型，赋值和函数传参都会复制整个数组，相当于是原数组的拷贝。
初始化 数组有两种初始化的方式，一种是显示声明数组的长度，一种是使用[...]T声明数组。
arr1 := [3]int{0, 1, 2} arr2 := [...]int{0, 1, 2} 第二种初始化的方式属于 Go 语言提供的语法糖，在编译期间就会推导出数组的长度，最终转换成第一种，所以上述两种声明方式在运行期间得到的结果是相同的。
在编译期间，Go 会根据数组的元素数量，做出如下的优化：
当元素小于等于4个时，会直接将数组的元素在栈上面初始化； 当元素大于4个时，会将数组在静态区初始化然后复制到栈上面。 缺点 数组大小是固定的，但是很多场景中我们无法直接给出数组的确定长度。
数组是值类型，传递一个很大的数组给函数会消耗很多内存。
切片 由于数组的固定长度和值传递不够灵活，所以 Go 语言中，拥有不定长度的引用类型切片（slice）更加常用。
切片是对数组一个连续片段的引用，这些片段可以是整个数组，或者是由其实和终止索引表示的一些项的子集。
数据结构 切片的数据结构在源码包中定义
// go 1.20 src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 其中，array表示指向相关数组的指针，len表示切片长度，cap表示当前切片的容量，即底层数组的大小。其中底层数组是可以被多个 slice 同时指向的，所以对一个 slice 中的元素进行操作，可能也会影响到其他slice."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yanhuan0802.github.io/posts/"},{"@type":"ListItem","position":3,"name":"深入理解 Go 数组和切片底层实现","item":"https://yanhuan0802.github.io/posts/explore-go-array-slice/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入理解 Go 数组和切片底层实现","name":"深入理解 Go 数组和切片底层实现","description":"数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。\n数组 数据结构 数组是计算机科学中的一种数据结构，它具有以下几个特点：\n元素类型相同，存储宽度一致 存储在一段连续的内存空间 空间大小固定，不能修改（会出现数据溢出问题） 可以通过元素索引计算出元素的存储地址 几乎所有的计算机语言，对于数组的实现都是相似的，都拥有上述特性，Go语言也一样。\n不同于 C 语言或其他语言，Go 语言数组是值类型，定义的时候就需要指定大小，数组大小是它类型的一部分，不同大小的数组相当于不同的类型，赋值和函数传参都会复制整个数组，相当于是原数组的拷贝。\n初始化 数组有两种初始化的方式，一种是显示声明数组的长度，一种是使用[...]T声明数组。\narr1 := [3]int{0, 1, 2} arr2 := [...]int{0, 1, 2} 第二种初始化的方式属于 Go 语言提供的语法糖，在编译期间就会推导出数组的长度，最终转换成第一种，所以上述两种声明方式在运行期间得到的结果是相同的。\n在编译期间，Go 会根据数组的元素数量，做出如下的优化：\n当元素小于等于4个时，会直接将数组的元素在栈上面初始化； 当元素大于4个时，会将数组在静态区初始化然后复制到栈上面。 缺点 数组大小是固定的，但是很多场景中我们无法直接给出数组的确定长度。\n数组是值类型，传递一个很大的数组给函数会消耗很多内存。\n切片 由于数组的固定长度和值传递不够灵活，所以 Go 语言中，拥有不定长度的引用类型切片（slice）更加常用。\n切片是对数组一个连续片段的引用，这些片段可以是整个数组，或者是由其实和终止索引表示的一些项的子集。\n数据结构 切片的数据结构在源码包中定义\n// go 1.20 src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 其中，array表示指向相关数组的指针，len表示切片长度，cap表示当前切片的容量，即底层数组的大小。其中底层数组是可以被多个 slice 同时指向的，所以对一个 slice 中的元素进行操作，可能也会影响到其他slice.","keywords":["Go"],"articleBody":"数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。\n数组 数据结构 数组是计算机科学中的一种数据结构，它具有以下几个特点：\n元素类型相同，存储宽度一致 存储在一段连续的内存空间 空间大小固定，不能修改（会出现数据溢出问题） 可以通过元素索引计算出元素的存储地址 几乎所有的计算机语言，对于数组的实现都是相似的，都拥有上述特性，Go语言也一样。\n不同于 C 语言或其他语言，Go 语言数组是值类型，定义的时候就需要指定大小，数组大小是它类型的一部分，不同大小的数组相当于不同的类型，赋值和函数传参都会复制整个数组，相当于是原数组的拷贝。\n初始化 数组有两种初始化的方式，一种是显示声明数组的长度，一种是使用[...]T声明数组。\narr1 := [3]int{0, 1, 2} arr2 := [...]int{0, 1, 2} 第二种初始化的方式属于 Go 语言提供的语法糖，在编译期间就会推导出数组的长度，最终转换成第一种，所以上述两种声明方式在运行期间得到的结果是相同的。\n在编译期间，Go 会根据数组的元素数量，做出如下的优化：\n当元素小于等于4个时，会直接将数组的元素在栈上面初始化； 当元素大于4个时，会将数组在静态区初始化然后复制到栈上面。 缺点 数组大小是固定的，但是很多场景中我们无法直接给出数组的确定长度。\n数组是值类型，传递一个很大的数组给函数会消耗很多内存。\n切片 由于数组的固定长度和值传递不够灵活，所以 Go 语言中，拥有不定长度的引用类型切片（slice）更加常用。\n切片是对数组一个连续片段的引用，这些片段可以是整个数组，或者是由其实和终止索引表示的一些项的子集。\n数据结构 切片的数据结构在源码包中定义\n// go 1.20 src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 其中，array表示指向相关数组的指针，len表示切片长度，cap表示当前切片的容量，即底层数组的大小。其中底层数组是可以被多个 slice 同时指向的，所以对一个 slice 中的元素进行操作，可能也会影响到其他slice.\n由于切片结构体中直接存储了切片的长度和容量，所以内置函数len()和cap()操作的时间复杂度均为O(1).\n切片在运行时的表示:\n// go 1.20 src/reflect/value.go // Deprecated: Use unsafe.Slice or unsafe.SliceData instead. type SliceHeader struct { Data uintptr Len int Cap int } // go 1.20 src/unsafe/unsafe.go // SliceData returns a pointer to the underlying array of the argument // slice. // - If cap(slice) \u003e 0, SliceData returns \u0026slice[:1][0]. // - If slice == nil, SliceData returns nil. // - Otherwise, SliceData returns a non-nil pointer to an // unspecified memory address. func SliceData(slice []ArbitraryType) *ArbitraryType 初始化 变量声明 var s []int 使用这种方式创建出来的 slice 是变量零值，即 nil。它的长度和容量都是 0 ，和nil相等。nil切片可以通过append函数来完成内存申请和元素追加。\n字面量 s1 := []int{} // 空切片 s2 := []int{1, 2} // 长度为3的切片 s3 := []int{0, 1, 2, 3, 8: 100} // 使用索引号直接复制，将索引为 8 位置的元素赋值为 100 其中，空切片指的是切片长度为 0 ，但是值并不是nil，声明长度为 0 的切片时，尽量使用nil切片，这样就不需要进行内存分配。\nmake 函数 s1 := make([]int, 10) // 指定长度，此时容量默认和长度相等 s2 := make([]int, 10, 30) //指定长度和容量 创建时，底层会分配一个数组，数组的长度就是切片的容量。\n创建切片时的运行运行时函数如下：\n// go 1.20 src/runtime/slice.go func makeslice(et *_type, len, cap int) unsafe.Pointer { // 内存空间 = 元素大小 * 切片容量 mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // panic 条件 // 1.内存空间溢出 // 2.申请的内存空间大于最大可分配的内存 // 3.长度小于 0 或大于容量 if overflow || mem \u003e maxAlloc || len \u003c 0 || len \u003e cap { mem, overflow := math.MulUintptr(et.size, uintptr(len)) if overflow || mem \u003e maxAlloc || len \u003c 0 { panicmakeslicelen() } panicmakeslicecap() } // 内存申请：小对象在 P 结构中初始化，大于 32KB 在堆中初始化 return mallocgc(mem, et, true) } 通过下标从数组或切片中切取 s1 := array[1:5] s2 := sourceSlice[1:5] 使用下标初始化不会复制原数组或者原切片中的数据，只会创建一个指向原数组的结构体，数组后面的内容都作为切片的预留内存。 同时，slice 将和原数组共用一部分内存，对数组或slice元素的修改，都会影响到彼此。如果因为执行append操作使得新的 slice 底层数组扩容，移动到了新的位置，那么两者就不会互相影响了。\n追加和扩容 追加 使用 append函数可以向切片中追加元素：\nfunc append(slice []Type, elems ...Type) []Type append函数的参数长度可变，所以可以追加多个值到 slice 中，还可以用 ...传入 slice，直接追加一个切片。\ns1 = append(s1, 1, 2, 3) s1 = append(s1, s2...) append函数返回值是一个新的 slice，可以选择覆盖原 slice，也可以选择定义赋值给新的 slice，但是 Go 编译器不允许调用了 append函数后不使用返回值。\n扩容 使用append向 slice 中追加元素，实际上是向底层数组添加元素，如果 slice 底层数组空间不足，就会触发 slice 扩容。\n扩容就是为切片分配新的内存空间并复制原切片中元素的过程。新的底层数组长度大于原有的 slice 底层数组，这样就可以进行append操作，具体的扩容策略如下：\n// go 1.20 src/runtime/slice.go func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice { ... // 扩容策略 newcap := oldCap doublecap := newcap + newcap if newLen \u003e doublecap { // 期望大小大于当前容量的两倍，使用期望大小 newcap = newLen } else { // 期望大小小于当前容量的两倍 const threshold = 256 if oldCap \u003c threshold { // 原容量小于 256 ，容量翻倍 newcap = doublecap } else { // 原容量大于256 // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. // 保证 newcap \u003e newLen for 0 \u003c newcap \u0026\u0026 newcap \u003c newLen { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. // 每次增加 25% + 192，比 Go1.18 之前更加平滑 newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. // 溢出情况处理 if newcap \u003c= 0 { newcap = newLen } } } ... } 在运行时，根据新长度的大小，选择了不同的策略进行扩容：\n如果期望大小大于当前容量的两倍，新容量就会使用期望大小 否则判断，如果旧切片的容量小于 256，新容量就会是旧容量的两倍 否则判断，如果旧切片的容量大于256，新容量就会使用从旧容量开始循环增加，每次增加25% + 192，直到新容量大于等于新长度。 如果新容量计算溢出了，就使用新长度作为新容量。 这个扩容策略是在 Go 1.18 开始执行的，相比 Go 1.18 之前使用 1024 作为扩容基准值，这个策略则更加平滑。\n经过上述策略，得到的新容量只能说是一个大致容量，最终的容量和内存大小，还需要根据切片中的元素大小进行内存对齐。具体内存对齐代码如下所示：\n// go 1.20 src/runtime/slice.go func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice { ... // 新长度及容量大小计算，根据切片中元素大小进行内存对齐 var overflow bool var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don't need any division/multiplication. // For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. switch { case et.size == 1: lenmem = uintptr(oldLen) newlenmem = uintptr(newLen) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) \u003e maxAlloc newcap = int(capmem) case et.size == goarch.PtrSize: lenmem = uintptr(oldLen) * goarch.PtrSize newlenmem = uintptr(newLen) * goarch.PtrSize capmem = roundupsize(uintptr(newcap) * goarch.PtrSize) overflow = uintptr(newcap) \u003e maxAlloc/goarch.PtrSize newcap = int(capmem / goarch.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if goarch.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.TrailingZeros64(uint64(et.size))) \u0026 63 } else { shift = uintptr(sys.TrailingZeros32(uint32(et.size))) \u0026 31 } lenmem = uintptr(oldLen) \u003c\u003c shift newlenmem = uintptr(newLen) \u003c\u003c shift capmem = roundupsize(uintptr(newcap) \u003c\u003c shift) overflow = uintptr(newcap) \u003e (maxAlloc \u003e\u003e shift) newcap = int(capmem \u003e\u003e shift) capmem = uintptr(newcap) \u003c\u003c shift default: lenmem = uintptr(oldLen) * et.size newlenmem = uintptr(newLen) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) capmem = uintptr(newcap) * et.size } ... } // go 1.20 src/runtime/msize.go func roundupsize(size uintptr) uintptr { if size \u003c _MaxSmallSize { if size \u003c= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } if size+_PageSize \u003c size { return size } return alignUp(size, _PageSize) } // go 1.20 src/runtime/sizeclass.go const ( _MaxSmallSize = 32768 smallSizeDiv = 8 smallSizeMax = 1024 largeSizeDiv = 128 _NumSizeClasses = 68 _PageShift = 13 ) // 这是 Go 源码中有关内存分配的 slice。 // class_to_size 通过 spanClass获取 span划分的 object大小。 // 而 size_to_class8 size_to_class128 表示通过 size 获取它的 spanClass var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32} var size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + 1]uint8{32, 33, 34, 35, 36, 37, 37, 38, 38, 39, 39, 40, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67} // go 1.20 src/runtime/stubs.go func divRoundUp(n, a uintptr) uintptr { // a is generally a power of two. This will get inlined and // the compiler will optimize the division. return (n + a - 1) / a } rounddupsize函数会将待申请的内存向上取整，取整时会使用class_to_size数组，提高了内存分配效率并减少碎片。\n接下来，就是进行内存分配，复制数据，append元素到新的底层数组。\n// go 1.20 src/runtime/slice.go func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice { ... // 计算内存溢出 if overflow || capmem \u003e maxAlloc { panic(errorString(\"growslice: len out of range\")) } var p unsafe.Pointer if et.ptrdata == 0 { // 切片中的元素不是指针类型 // 分配内存 p = mallocgc(capmem, nil, false) // 清除不会覆盖的部分 memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem) } else { // 切片中的元素是指针类型 // 分配内存 p = mallocgc(capmem, et, true) if lenmem \u003e 0 \u0026\u0026 writeBarrier.enabled { // 内存屏障 bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(oldPtr), lenmem-et.size+et.ptrdata) } } // 复制原数组内存中的内容到新申请的内存中 memmove(p, oldPtr, lenmem) return slice{p, newLen, newcap} } 此外，nil切片和空切片都是可以通过调用append函数来获得底层数组的扩容，最终都是通过mallocgc来进行内存申请，再赋值给原来的nil切片或空切片，所以nil切片是可以调动append函数的。\n我们用一个常见的例子总结一下扩容的过程\nfunc main() { s := []int{1, 2} s = append(s, 3, 4, 5) fmt.Printf(\"len=%d, cap=%d\",len(s), cap(s)) } 程序运行结果为：\nlen = 5, cap = 6 在上述代码执行的过程中，我们先初始化了一个长度和容量均为 2 的切片 s ，然后向 s 中追加三个元素，此时就会触发扩容，期望大小为 5，5 大于当前容量的两倍，所以初步计算的 newcap 为 5，在 64 位机器上一个指针的大小为 8 字节，所以期望分配的内存大小为 40 字节。然后要进行内存对齐计算，调用roundupsize进行向上取整，计算结果如下所示：\n// capmem 计算公式 class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]] divRoundUp(40, 8) = 5 size_to_class8[5] = 5 capmem = class_to_size[5] = 48 // newcap 计算 newcap = int(capmem / goarch.PtrSize) = 48/8 = 6 所以，最终新的 slice 容量为 6.\n拷贝 使用copy函数可以进行切片的拷贝操作，具体实现如下所示：\n// go 1.20 src/runtime/slice.go // 元素类型为string 或者 无指针 元素切片copy func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int { // 如果长度为0，不需要 copy if fromLen == 0 || toLen == 0 { return 0 } // 记录源切片或者目标切片中较短的长度 n := fromLen if toLen \u003c n { n = toLen } // 元素类型宽度为0，也不需要执行 copy 操作，直接返回短切片的长度 if width == 0 { return n } // 计算大小 size := uintptr(n) * width ... if size == 1 { // common case worth about 2x to do here // TODO: is this still worth it with new memmove impl? // 如果 size 大小为1，那么指针直接转换即可 *(*byte)(toPtr) = *(*byte)(fromPtr) // known to be a byte pointer } else { // 使用 memmove 将 size 大小的内存复制到目标区域 memmove(toPtr, fromPtr, size) } return n } // go 1.20 src/runtime/mbarrier.go // 指针类型的元素切片 copy func typedslicecopy(typ *_type, dstPtr unsafe.Pointer, dstLen int, srcPtr unsafe.Pointer, srcLen int) int { // copy 长度计算 n := dstLen if n \u003e srcLen { n = srcLen } if n == 0 { return 0 } ... if writeBarrier.cgo { cgoCheckSliceCopy(typ, dstPtr, srcPtr, n) } // 指针相等，不需要copy了 if dstPtr == srcPtr { return n } // 内存大小计算 size := uintptr(n) * typ.size if writeBarrier.needed { pwsize := size - typ.size + typ.ptrdata bulkBarrierPreWrite(uintptr(dstPtr), uintptr(srcPtr), pwsize) } // 内存 copy memmove(dstPtr, srcPtr, size) return n } 上述代码分别是 string 及 元素无指针类型 切片以及指针类型元素切片的拷贝，其实现方法是类似的，即\n拷贝长度为两个切片长度的最小值 拷贝内容为源切片中对应拷贝长度的整块内存的内容 返回值为被拷贝的元素的个数 由此也可以得出，在拷贝的过程中，不会发生扩容。\n此外，在 range遍历的过程中，获得的 value 其实是切片中的值拷贝，并且每次都是拷贝到同一个地址，所以在遍历中拿到的 value 的地址是不变的，如下所示：\nfunc main() { slice := []int{10, 20, 30, 40} for index, value := range slice { fmt.Printf(\"value = %d , value-addr = %x , slice-addr = %x\\n\", value, \u0026value, \u0026slice[index]) } } 输出结果：\nvalue = 10, value-addr = 14000126008, slice-addr = 1400012e000 value = 20, value-addr = 14000126008, slice-addr = 1400012e008 value = 30, value-addr = 14000126008 , slice-addr = 1400012e010 value = 40 , value-addr = 14000126008, slice-addr = 1400012e018 参数传递 首先，我们必须明确一点，Go 语言中的函数参数传递，只有值传递，没有引用传递。\n下面我们举几个例子来看看 slice 在函数参数传递中的一些细节。\nslice 和 slice 指针 代码示例：\nfunc Append(s []int) { s = append(s, 100) fmt.Printf(\"param s: %v \\n \", s) } func AppendPtr(s *[]int) { *s = append(*s, 200) fmt.Printf(\"param *s: %v \\n \", *s) } func main() { s1 := []int{1, 1, 1} Append(s1) fmt.Printf(\"main s1: %v \\n \", s1) s2 := []int{1, 2, 3} AppendPtr(\u0026s2) fmt.Printf(\"main *s2: %v \\n \", s2) } 程序运行结果为：\nparam s: [1 1 1 100] main s1: [1 1 1] param *s: [1 2 3 200] main *s2: [1 2 3 200] 可以看出，在Append函数中，参数为 slice 值，所以对参数的变更，并不会影响到外层的 s.\n但是，将 s 指针传入AppendPtr，在函数中对参数做出的改变，是会影响到外层的 s.\nslice append 操作 代码示例：\nfunc SliceRise(s []int) { s = append(s, 0) for i := range s { s[i]++ } } func main() { s1 := []int{1, 2} s2 := s1 s2 = append(s2, 3) SliceRise(s1) SliceRise(s2) fmt.Println(s1, s2) } 程序运行结果为：\n[1 2] [2 3 4] 首先，SliceRise()函数中 slice 作为参数，是一个值传递，函数调用时，会拷贝原 slice 的值，对于值的修改不会影响外层的 slice。\n对于 s1 来说，底层数组本身的长度和容量均为2，传递进函数后，进行了 append 操作，这个 append 操作会引发切片的扩容，扩容后会产生一个新的底层数组，这个数组继续赋值给了变量 s。 此时，s1 和 s 指向的底层数组就不一样了，所以 s1 本身和它指向的底层数组，都没有发生任何变化，打印 s1 的结果仍然是 1 2.\n对于 s2 来说，最初 s2 和 s1 指向同一个底层数组，进行 append 操作之后，发生了扩容，并且将 append 之后的新切片赋值给了 s2， 到这里，s1 和 s2 就指向不同的底层数组了。 s2 传递进函数后，进行了 append 操作，这个 append 操作不会引发切片的扩容，这个数组继续赋值给了变量 s。 此时，s2 和 s 依旧共享底层数组，但是s 的长度 len 变成 4 了，而由于函数参数值传递的特点，s2 的长度 len 并不会被改变，所以在进行遍历对元素进行操作之后， 虽然对于 s 和底层数组来说，值变成了2 3 4 1，但是对于 s2 来说，它的长度是 3，所以打印 s2 的结果会是2 3 4.\n总结 数组存储的是一组元素类型相同，存储宽度一致的元素，它们存储在一段连续的内存空间，Go 中的数组是值类型，并且数组大小是固定的。 切片是对底层数组的一个抽象，表述的是对数组一个连续片段的引用。 切片结构体中包含了长度，容量以及底层数组地址，多个切片可以共享同一个底层数组。 append函数可以向切片中追加元素，并生成一个新的切片。当切片容量不足的情况下，append函数会先调用growslice进行扩容，然后再进行元素的追加。 切片扩容后容量的计算分为按照策略计算和内存对齐两部分。扩容后的容量 \u003e= 原容量的两倍 或 1.25倍+192 切片作为函数参数时是值传递，在函数中操作切片时，可能改变切边中的元素，但是不会改变切片本身。 参考资料 Go 语言设计与实现 Go 专家编程 深度解密 Go 语言之 slice 深入解析 Go 中 Slice 底层实现 【Go】深入剖析slice和array ","wordCount":"2032","inLanguage":"en","datePublished":"2023-04-22T20:33:06+08:00","dateModified":"2023-04-23T16:31:53+08:00","author":{"@type":"Person","name":"Yan Huan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yanhuan0802.github.io/posts/explore-go-array-slice/"},"publisher":{"@type":"Organization","name":"YanHuan's World","logo":{"@type":"ImageObject","url":"https://yanhuan0802.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yanhuan0802.github.io accesskey=h title="YanHuan's World (Alt + H)">YanHuan's World</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yanhuan0802.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://yanhuan0802.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yanhuan0802.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yanhuan0802.github.io>Home</a>&nbsp;»&nbsp;<a href=https://yanhuan0802.github.io/posts/>Posts</a></div><h1 class=post-title>深入理解 Go 数组和切片底层实现</h1><div class=post-meta><span title='2023-04-22 20:33:06 +0800 CST'>April 22, 2023</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2032 words&nbsp;·&nbsp;Yan Huan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#数组>数组</a><ul><li><a href=#数据结构>数据结构</a></li><li><a href=#初始化>初始化</a></li><li><a href=#缺点>缺点</a></li></ul></li><li><a href=#切片>切片</a><ul><li><a href=#数据结构-1>数据结构</a></li><li><a href=#初始化-1>初始化</a></li><li><a href=#追加和扩容>追加和扩容</a></li><li><a href=#拷贝>拷贝</a></li><li><a href=#参数传递>参数传递</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div><div class=post-content><p>数组<code>array</code>和切片<code>slice</code>是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。</p><h2 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h2><h3 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h3><p>数组是计算机科学中的一种数据结构，它具有以下几个特点：</p><ul><li>元素类型相同，存储宽度一致</li><li>存储在一段连续的内存空间</li><li>空间大小固定，不能修改（会出现数据溢出问题）</li><li>可以通过元素索引计算出元素的存储地址</li></ul><p>几乎所有的计算机语言，对于数组的实现都是相似的，都拥有上述特性，Go语言也一样。</p><p>不同于 C 语言或其他语言，Go 语言数组是值类型，定义的时候就需要指定大小，数组大小是它类型的一部分，不同大小的数组相当于不同的类型，赋值和函数传参都会复制整个数组，相当于是原数组的拷贝。</p><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><p>数组有两种初始化的方式，一种是显示声明数组的长度，一种是使用<code>[...]T</code>声明数组。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arr1</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>arr2</span> <span class=o>:=</span> <span class=p>[</span><span class=o>...</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span></code></pre></div><p>第二种初始化的方式属于 Go 语言提供的语法糖，在编译期间就会推导出数组的长度，最终转换成第一种，所以上述两种声明方式在运行期间得到的结果是相同的。</p><p>在编译期间，Go 会根据数组的元素数量，做出如下的优化：</p><ul><li>当元素小于等于4个时，会直接将数组的元素在栈上面初始化；</li><li>当元素大于4个时，会将数组在静态区初始化然后复制到栈上面。</li></ul><h3 id=缺点>缺点<a hidden class=anchor aria-hidden=true href=#缺点>#</a></h3><p>数组大小是固定的，但是很多场景中我们无法直接给出数组的确定长度。</p><p>数组是值类型，传递一个很大的数组给函数会消耗很多内存。</p><h2 id=切片>切片<a hidden class=anchor aria-hidden=true href=#切片>#</a></h2><p>由于数组的固定长度和值传递不够灵活，所以 Go 语言中，拥有不定长度的引用类型切片（slice）更加常用。</p><p>切片是对数组一个连续片段的引用，这些片段可以是整个数组，或者是由其实和终止索引表示的一些项的子集。</p><h3 id=数据结构-1>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构-1>#</a></h3><p>切片的数据结构在源码包中定义</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// go 1.20 src/runtime/slice.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>slice</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>array</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 元素指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>len</span>   <span class=kt>int</span> <span class=c1>// 长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>cap</span>   <span class=kt>int</span> <span class=c1>// 容量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>其中，<code>array</code>表示指向相关数组的指针，<code>len</code>表示切片长度，<code>cap</code>表示当前切片的容量，即底层数组的大小。其中底层数组是可以被多个 slice 同时指向的，所以对一个 slice 中的元素进行操作，可能也会影响到其他slice.</p><p>由于切片结构体中直接存储了切片的长度和容量，所以内置函数<code>len()</code>和<code>cap()</code>操作的时间复杂度均为<code>O(1)</code>.</p><p>切片在运行时的表示:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// go 1.20 src/reflect/value.go
</span></span></span><span class=line><span class=cl><span class=c1>// Deprecated: Use unsafe.Slice or unsafe.SliceData instead.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>SliceHeader</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>    <span class=nx>Len</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Cap</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// go 1.20 src/unsafe/unsafe.go
</span></span></span><span class=line><span class=cl><span class=c1>// SliceData returns a pointer to the underlying array of the argument
</span></span></span><span class=line><span class=cl><span class=c1>// slice.
</span></span></span><span class=line><span class=cl><span class=c1>//   - If cap(slice) &gt; 0, SliceData returns &amp;slice[:1][0].
</span></span></span><span class=line><span class=cl><span class=c1>//   - If slice == nil, SliceData returns nil.
</span></span></span><span class=line><span class=cl><span class=c1>//   - Otherwise, SliceData returns a non-nil pointer to an
</span></span></span><span class=line><span class=cl><span class=c1>//     unspecified memory address.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>SliceData</span><span class=p>(</span><span class=nx>slice</span> <span class=p>[]</span><span class=nx>ArbitraryType</span><span class=p>)</span> <span class=o>*</span><span class=nx>ArbitraryType</span>
</span></span></code></pre></div><h3 id=初始化-1>初始化<a hidden class=anchor aria-hidden=true href=#初始化-1>#</a></h3><ul><li>变量声明</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span>
</span></span></code></pre></div><p>使用这种方式创建出来的 slice 是变量零值，即 <code>nil</code>。它的长度和容量都是 0 ，和<code>nil</code>相等。<code>nil</code>切片可以通过<code>append</code>函数来完成内存申请和元素追加。</p><ul><li>字面量</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>                   <span class=c1>// 空切片
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>               <span class=c1>// 长度为3的切片
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s3</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>8</span><span class=p>:</span> <span class=mi>100</span><span class=p>}</span> <span class=c1>// 使用索引号直接复制，将索引为 8 位置的元素赋值为 100
</span></span></span></code></pre></div><p>其中，空切片指的是切片长度为 0 ，但是值并不是<code>nil</code>，声明长度为 0 的切片时，尽量使用<code>nil</code>切片，这样就不需要进行内存分配。</p><ul><li>make 函数</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span> <span class=c1>// 指定长度，此时容量默认和长度相等
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>30</span><span class=p>)</span> <span class=c1>//指定长度和容量
</span></span></span></code></pre></div><p>创建时，底层会分配一个数组，数组的长度就是切片的容量。</p><p>创建切片时的运行运行时函数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// go 1.20 src/runtime/slice.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>makeslice</span><span class=p>(</span><span class=nx>et</span> <span class=o>*</span><span class=nx>_type</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 内存空间 = 元素大小 * 切片容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mem</span><span class=p>,</span> <span class=nx>overflow</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>cap</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// panic 条件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 1.内存空间溢出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 2.申请的内存空间大于最大可分配的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 3.长度小于 0 或大于容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>overflow</span> <span class=o>||</span> <span class=nx>mem</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span> <span class=o>||</span> <span class=nx>len</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>len</span> <span class=p>&gt;</span> <span class=nx>cap</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>mem</span><span class=p>,</span> <span class=nx>overflow</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>len</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>overflow</span> <span class=o>||</span> <span class=nx>mem</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span> <span class=o>||</span> <span class=nx>len</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>panicmakeslicelen</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>panicmakeslicecap</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 内存申请：小对象在 P 结构中初始化，大于 32KB 在堆中初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nx>mem</span><span class=p>,</span> <span class=nx>et</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>通过下标从数组或切片中切取</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s1</span> <span class=o>:=</span> <span class=nx>array</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>s2</span> <span class=o>:=</span> <span class=nx>sourceSlice</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>5</span><span class=p>]</span>
</span></span></code></pre></div><p>使用下标初始化不会复制原数组或者原切片中的数据，只会创建一个指向原数组的结构体，数组后面的内容都作为切片的预留内存。
同时，slice 将和原数组共用一部分内存，对数组或slice元素的修改，都会影响到彼此。如果因为执行<code>append</code>操作使得新的 slice 底层数组扩容，移动到了新的位置，那么两者就不会互相影响了。</p><h3 id=追加和扩容>追加和扩容<a hidden class=anchor aria-hidden=true href=#追加和扩容>#</a></h3><h4 id=追加>追加<a hidden class=anchor aria-hidden=true href=#追加>#</a></h4><p>使用 <code>append</code>函数可以向切片中追加元素：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nb>append</span><span class=p>(</span><span class=nx>slice</span> <span class=p>[]</span><span class=nx>Type</span><span class=p>,</span> <span class=nx>elems</span> <span class=o>...</span><span class=nx>Type</span><span class=p>)</span> <span class=p>[]</span><span class=nx>Type</span>
</span></span></code></pre></div><p><code>append</code>函数的参数长度可变，所以可以追加多个值到 slice 中，还可以用 <code>...</code>传入 slice，直接追加一个切片。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s1</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>s1</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=nx>s2</span><span class=o>...</span><span class=p>)</span>
</span></span></code></pre></div><p><code>append</code>函数返回值是一个新的 slice，可以选择覆盖原 slice，也可以选择定义赋值给新的 slice，但是 Go 编译器不允许调用了 <code>append</code>函数后不使用返回值。</p><h4 id=扩容>扩容<a hidden class=anchor aria-hidden=true href=#扩容>#</a></h4><p>使用<code>append</code>向 slice 中追加元素，实际上是向底层数组添加元素，如果 slice 底层数组空间不足，就会触发 slice 扩容。</p><p>扩容就是为切片分配新的内存空间并复制原切片中元素的过程。新的底层数组长度大于原有的 slice 底层数组，这样就可以进行<code>append</code>操作，具体的扩容策略如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// go 1.20  src/runtime/slice.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>growslice</span><span class=p>(</span><span class=nx>oldPtr</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>newLen</span><span class=p>,</span> <span class=nx>oldCap</span><span class=p>,</span> <span class=nx>num</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>et</span> <span class=o>*</span><span class=nx>_type</span><span class=p>)</span> <span class=nx>slice</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 扩容策略
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>newcap</span> <span class=o>:=</span> <span class=nx>oldCap</span>
</span></span><span class=line><span class=cl>    <span class=nx>doublecap</span> <span class=o>:=</span> <span class=nx>newcap</span> <span class=o>+</span> <span class=nx>newcap</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>newLen</span> <span class=p>&gt;</span> <span class=nx>doublecap</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 期望大小大于当前容量的两倍，使用期望大小
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>newcap</span> <span class=p>=</span> <span class=nx>newLen</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 期望大小小于当前容量的两倍
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>const</span> <span class=nx>threshold</span> <span class=p>=</span> <span class=mi>256</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>oldCap</span> <span class=p>&lt;</span> <span class=nx>threshold</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 原容量小于 256 ，容量翻倍
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>newcap</span> <span class=p>=</span> <span class=nx>doublecap</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 原容量大于256
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// Check 0 &lt; newcap to detect overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// and prevent an infinite loop.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 保证 newcap &gt; newLen
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=mi>0</span> <span class=p>&lt;</span> <span class=nx>newcap</span> <span class=o>&amp;&amp;</span> <span class=nx>newcap</span> <span class=p>&lt;</span> <span class=nx>newLen</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Transition from growing 2x for small slices
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// to growing 1.25x for large slices. This formula
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// gives a smooth-ish transition between the two.
</span></span></span><span class=line><span class=cl><span class=c1></span>                
</span></span><span class=line><span class=cl>                <span class=c1>// 每次增加 25% + 192，比 Go1.18 之前更加平滑
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>newcap</span> <span class=o>+=</span> <span class=p>(</span><span class=nx>newcap</span> <span class=o>+</span> <span class=mi>3</span><span class=o>*</span><span class=nx>threshold</span><span class=p>)</span> <span class=o>/</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Set newcap to the requested cap when
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// the newcap calculation overflowed.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 溢出情况处理
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>newcap</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>newcap</span> <span class=p>=</span> <span class=nx>newLen</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在运行时，根据新长度的大小，选择了不同的策略进行扩容：</p><ul><li>如果期望大小大于当前容量的两倍，新容量就会使用期望大小</li><li>否则判断，如果旧切片的容量小于 256，新容量就会是旧容量的两倍</li><li>否则判断，如果旧切片的容量大于256，新容量就会使用从旧容量开始循环增加，每次增加<code>25% + 192</code>，直到新容量大于等于新长度。</li><li>如果新容量计算溢出了，就使用新长度作为新容量。</li></ul><p>这个扩容策略是在 Go 1.18 开始执行的，相比 Go 1.18 之前使用 1024 作为扩容基准值，这个策略则更加平滑。</p><p>经过上述策略，得到的新容量只能说是一个大致容量，最终的容量和内存大小，还需要根据切片中的元素大小进行内存对齐。具体内存对齐代码如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// go 1.20  src/runtime/slice.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>growslice</span><span class=p>(</span><span class=nx>oldPtr</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>newLen</span><span class=p>,</span> <span class=nx>oldCap</span><span class=p>,</span> <span class=nx>num</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>et</span> <span class=o>*</span><span class=nx>_type</span><span class=p>)</span> <span class=nx>slice</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 新长度及容量大小计算，根据切片中元素大小进行内存对齐
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>overflow</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>lenmem</span><span class=p>,</span> <span class=nx>newlenmem</span><span class=p>,</span> <span class=nx>capmem</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Specialize for common values of et.size.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// For 1 we don&#39;t need any division/multiplication.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// For powers of 2, use a variable shift.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>et</span><span class=p>.</span><span class=nx>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>lenmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>oldLen</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>newlenmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newLen</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>capmem</span> <span class=p>=</span> <span class=nf>roundupsize</span><span class=p>(</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nx>overflow</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span>
</span></span><span class=line><span class=cl>        <span class=nx>newcap</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>capmem</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>et</span><span class=p>.</span><span class=nx>size</span> <span class=o>==</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>lenmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>oldLen</span><span class=p>)</span> <span class=o>*</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span>
</span></span><span class=line><span class=cl>        <span class=nx>newlenmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newLen</span><span class=p>)</span> <span class=o>*</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span>
</span></span><span class=line><span class=cl>        <span class=nx>capmem</span> <span class=p>=</span> <span class=nf>roundupsize</span><span class=p>(</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>)</span> <span class=o>*</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>overflow</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span><span class=o>/</span><span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span>
</span></span><span class=line><span class=cl>        <span class=nx>newcap</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>capmem</span> <span class=o>/</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nf>isPowerOfTwo</span><span class=p>(</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>shift</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span> <span class=o>==</span> <span class=mi>8</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Mask shift for better code generation.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>shift</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>sys</span><span class=p>.</span><span class=nf>TrailingZeros64</span><span class=p>(</span><span class=nb>uint64</span><span class=p>(</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>)))</span> <span class=o>&amp;</span> <span class=mi>63</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>shift</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>sys</span><span class=p>.</span><span class=nf>TrailingZeros32</span><span class=p>(</span><span class=nb>uint32</span><span class=p>(</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>)))</span> <span class=o>&amp;</span> <span class=mi>31</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>lenmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>oldLen</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=nx>shift</span>
</span></span><span class=line><span class=cl>        <span class=nx>newlenmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newLen</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=nx>shift</span>
</span></span><span class=line><span class=cl>        <span class=nx>capmem</span> <span class=p>=</span> <span class=nf>roundupsize</span><span class=p>(</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=nx>shift</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>overflow</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>)</span> <span class=p>&gt;</span> <span class=p>(</span><span class=nx>maxAlloc</span> <span class=o>&gt;&gt;</span> <span class=nx>shift</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>newcap</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>capmem</span> <span class=o>&gt;&gt;</span> <span class=nx>shift</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>capmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=nx>shift</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>lenmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>oldLen</span><span class=p>)</span> <span class=o>*</span> <span class=nx>et</span><span class=p>.</span><span class=nx>size</span>
</span></span><span class=line><span class=cl>        <span class=nx>newlenmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newLen</span><span class=p>)</span> <span class=o>*</span> <span class=nx>et</span><span class=p>.</span><span class=nx>size</span>
</span></span><span class=line><span class=cl>        <span class=nx>capmem</span><span class=p>,</span> <span class=nx>overflow</span> <span class=p>=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nx>capmem</span> <span class=p>=</span> <span class=nf>roundupsize</span><span class=p>(</span><span class=nx>capmem</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>newcap</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>capmem</span> <span class=o>/</span> <span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>capmem</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>newcap</span><span class=p>)</span> <span class=o>*</span> <span class=nx>et</span><span class=p>.</span><span class=nx>size</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// go 1.20  src/runtime/msize.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>roundupsize</span><span class=p>(</span><span class=nx>size</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>uintptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>size</span> <span class=p>&lt;</span> <span class=nx>_MaxSmallSize</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>size</span> <span class=o>&lt;=</span> <span class=nx>smallSizeMax</span><span class=o>-</span><span class=mi>8</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>class_to_size</span><span class=p>[</span><span class=nx>size_to_class8</span><span class=p>[</span><span class=nf>divRoundUp</span><span class=p>(</span><span class=nx>size</span><span class=p>,</span> <span class=nx>smallSizeDiv</span><span class=p>)]])</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>class_to_size</span><span class=p>[</span><span class=nx>size_to_class128</span><span class=p>[</span><span class=nf>divRoundUp</span><span class=p>(</span><span class=nx>size</span><span class=o>-</span><span class=nx>smallSizeMax</span><span class=p>,</span> <span class=nx>largeSizeDiv</span><span class=p>)]])</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>size</span><span class=o>+</span><span class=nx>_PageSize</span> <span class=p>&lt;</span> <span class=nx>size</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>size</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>alignUp</span><span class=p>(</span><span class=nx>size</span><span class=p>,</span> <span class=nx>_PageSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// go 1.20  src/runtime/sizeclass.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>_MaxSmallSize</span> <span class=p>=</span> <span class=mi>32768</span>
</span></span><span class=line><span class=cl>    <span class=nx>smallSizeDiv</span> <span class=p>=</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl>    <span class=nx>smallSizeMax</span> <span class=p>=</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>    <span class=nx>largeSizeDiv</span> <span class=p>=</span> <span class=mi>128</span>
</span></span><span class=line><span class=cl>    <span class=nx>_NumSizeClasses</span> <span class=p>=</span> <span class=mi>68</span>
</span></span><span class=line><span class=cl>    <span class=nx>_PageShift</span> <span class=p>=</span> <span class=mi>13</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是 Go 源码中有关内存分配的 slice。
</span></span></span><span class=line><span class=cl><span class=c1>// class_to_size 通过 spanClass获取 span划分的 object大小。
</span></span></span><span class=line><span class=cl><span class=c1>// 而 size_to_class8  size_to_class128 表示通过 size 获取它的 spanClass
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>class_to_size</span> <span class=p>=</span> <span class=p>[</span><span class=nx>_NumSizeClasses</span><span class=p>]</span><span class=kt>uint16</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>24</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>48</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>80</span><span class=p>,</span> <span class=mi>96</span><span class=p>,</span> <span class=mi>112</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>144</span><span class=p>,</span> <span class=mi>160</span><span class=p>,</span> <span class=mi>176</span><span class=p>,</span> <span class=mi>192</span><span class=p>,</span> <span class=mi>208</span><span class=p>,</span> <span class=mi>224</span><span class=p>,</span> <span class=mi>240</span><span class=p>,</span> <span class=mi>256</span><span class=p>,</span> <span class=mi>288</span><span class=p>,</span> <span class=mi>320</span><span class=p>,</span> <span class=mi>352</span><span class=p>,</span> <span class=mi>384</span><span class=p>,</span> <span class=mi>416</span><span class=p>,</span> <span class=mi>448</span><span class=p>,</span> <span class=mi>480</span><span class=p>,</span> <span class=mi>512</span><span class=p>,</span> <span class=mi>576</span><span class=p>,</span> <span class=mi>640</span><span class=p>,</span> <span class=mi>704</span><span class=p>,</span> <span class=mi>768</span><span class=p>,</span> <span class=mi>896</span><span class=p>,</span> <span class=mi>1024</span><span class=p>,</span> <span class=mi>1152</span><span class=p>,</span> <span class=mi>1280</span><span class=p>,</span> <span class=mi>1408</span><span class=p>,</span> <span class=mi>1536</span><span class=p>,</span> <span class=mi>1792</span><span class=p>,</span> <span class=mi>2048</span><span class=p>,</span> <span class=mi>2304</span><span class=p>,</span> <span class=mi>2688</span><span class=p>,</span> <span class=mi>3072</span><span class=p>,</span> <span class=mi>3200</span><span class=p>,</span> <span class=mi>3456</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=mi>4864</span><span class=p>,</span> <span class=mi>5376</span><span class=p>,</span> <span class=mi>6144</span><span class=p>,</span> <span class=mi>6528</span><span class=p>,</span> <span class=mi>6784</span><span class=p>,</span> <span class=mi>6912</span><span class=p>,</span> <span class=mi>8192</span><span class=p>,</span> <span class=mi>9472</span><span class=p>,</span> <span class=mi>9728</span><span class=p>,</span> <span class=mi>10240</span><span class=p>,</span> <span class=mi>10880</span><span class=p>,</span> <span class=mi>12288</span><span class=p>,</span> <span class=mi>13568</span><span class=p>,</span> <span class=mi>14336</span><span class=p>,</span> <span class=mi>16384</span><span class=p>,</span> <span class=mi>18432</span><span class=p>,</span> <span class=mi>19072</span><span class=p>,</span> <span class=mi>20480</span><span class=p>,</span> <span class=mi>21760</span><span class=p>,</span> <span class=mi>24576</span><span class=p>,</span> <span class=mi>27264</span><span class=p>,</span> <span class=mi>28672</span><span class=p>,</span> <span class=mi>32768</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>size_to_class8</span> <span class=p>=</span> <span class=p>[</span><span class=nx>smallSizeMax</span><span class=o>/</span><span class=nx>smallSizeDiv</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span><span class=kt>uint8</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>13</span><span class=p>,</span> <span class=mi>13</span><span class=p>,</span> <span class=mi>14</span><span class=p>,</span> <span class=mi>14</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>17</span><span class=p>,</span> <span class=mi>17</span><span class=p>,</span> <span class=mi>18</span><span class=p>,</span> <span class=mi>18</span><span class=p>,</span> <span class=mi>19</span><span class=p>,</span> <span class=mi>19</span><span class=p>,</span> <span class=mi>19</span><span class=p>,</span> <span class=mi>19</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>21</span><span class=p>,</span> <span class=mi>21</span><span class=p>,</span> <span class=mi>21</span><span class=p>,</span> <span class=mi>21</span><span class=p>,</span> <span class=mi>22</span><span class=p>,</span> <span class=mi>22</span><span class=p>,</span> <span class=mi>22</span><span class=p>,</span> <span class=mi>22</span><span class=p>,</span> <span class=mi>23</span><span class=p>,</span> <span class=mi>23</span><span class=p>,</span> <span class=mi>23</span><span class=p>,</span> <span class=mi>23</span><span class=p>,</span> <span class=mi>24</span><span class=p>,</span> <span class=mi>24</span><span class=p>,</span> <span class=mi>24</span><span class=p>,</span> <span class=mi>24</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>26</span><span class=p>,</span> <span class=mi>26</span><span class=p>,</span> <span class=mi>26</span><span class=p>,</span> <span class=mi>26</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>31</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>size_to_class128</span> <span class=p>=</span> <span class=p>[(</span><span class=nx>_MaxSmallSize</span><span class=o>-</span><span class=nx>smallSizeMax</span><span class=p>)</span><span class=o>/</span><span class=nx>largeSizeDiv</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span><span class=kt>uint8</span><span class=p>{</span><span class=mi>32</span><span class=p>,</span> <span class=mi>33</span><span class=p>,</span> <span class=mi>34</span><span class=p>,</span> <span class=mi>35</span><span class=p>,</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>37</span><span class=p>,</span> <span class=mi>37</span><span class=p>,</span> <span class=mi>38</span><span class=p>,</span> <span class=mi>38</span><span class=p>,</span> <span class=mi>39</span><span class=p>,</span> <span class=mi>39</span><span class=p>,</span> <span class=mi>40</span><span class=p>,</span> <span class=mi>40</span><span class=p>,</span> <span class=mi>40</span><span class=p>,</span> <span class=mi>41</span><span class=p>,</span> <span class=mi>41</span><span class=p>,</span> <span class=mi>41</span><span class=p>,</span> <span class=mi>42</span><span class=p>,</span> <span class=mi>43</span><span class=p>,</span> <span class=mi>43</span><span class=p>,</span> <span class=mi>44</span><span class=p>,</span> <span class=mi>44</span><span class=p>,</span> <span class=mi>44</span><span class=p>,</span> <span class=mi>44</span><span class=p>,</span> <span class=mi>44</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mi>46</span><span class=p>,</span> <span class=mi>46</span><span class=p>,</span> <span class=mi>46</span><span class=p>,</span> <span class=mi>46</span><span class=p>,</span> <span class=mi>47</span><span class=p>,</span> <span class=mi>47</span><span class=p>,</span> <span class=mi>47</span><span class=p>,</span> <span class=mi>47</span><span class=p>,</span> <span class=mi>47</span><span class=p>,</span> <span class=mi>47</span><span class=p>,</span> <span class=mi>48</span><span class=p>,</span> <span class=mi>48</span><span class=p>,</span> <span class=mi>48</span><span class=p>,</span> <span class=mi>49</span><span class=p>,</span> <span class=mi>49</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>51</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>52</span><span class=p>,</span> <span class=mi>53</span><span class=p>,</span> <span class=mi>53</span><span class=p>,</span> <span class=mi>54</span><span class=p>,</span> <span class=mi>54</span><span class=p>,</span> <span class=mi>54</span><span class=p>,</span> <span class=mi>54</span><span class=p>,</span> <span class=mi>55</span><span class=p>,</span> <span class=mi>55</span><span class=p>,</span> <span class=mi>55</span><span class=p>,</span> <span class=mi>55</span><span class=p>,</span> <span class=mi>55</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>57</span><span class=p>,</span> <span class=mi>58</span><span class=p>,</span> <span class=mi>58</span><span class=p>,</span> <span class=mi>58</span><span class=p>,</span> <span class=mi>58</span><span class=p>,</span> <span class=mi>58</span><span class=p>,</span> <span class=mi>58</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>61</span><span class=p>,</span> <span class=mi>61</span><span class=p>,</span> <span class=mi>61</span><span class=p>,</span> <span class=mi>61</span><span class=p>,</span> <span class=mi>61</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>63</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>65</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>66</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>,</span> <span class=mi>67</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// go 1.20  src/runtime/stubs.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>divRoundUp</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>a</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>uintptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// a is generally a power of two. This will get inlined and
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the compiler will optimize the division.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=nx>n</span> <span class=o>+</span> <span class=nx>a</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=nx>a</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>rounddupsize</code>函数会将待申请的内存向上取整，取整时会使用<code>class_to_size</code>数组，提高了内存分配效率并减少碎片。</p><p>接下来，就是进行内存分配，复制数据，<code>append</code>元素到新的底层数组。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// go 1.20  src/runtime/slice.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>growslice</span><span class=p>(</span><span class=nx>oldPtr</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>newLen</span><span class=p>,</span> <span class=nx>oldCap</span><span class=p>,</span> <span class=nx>num</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>et</span> <span class=o>*</span><span class=nx>_type</span><span class=p>)</span> <span class=nx>slice</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 计算内存溢出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>overflow</span> <span class=o>||</span> <span class=nx>capmem</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nf>errorString</span><span class=p>(</span><span class=s>&#34;growslice: len out of range&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>p</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>et</span><span class=p>.</span><span class=nx>ptrdata</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 切片中的元素不是指针类型
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>p</span> <span class=p>=</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nx>capmem</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 清除不会覆盖的部分
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>memclrNoHeapPointers</span><span class=p>(</span><span class=nf>add</span><span class=p>(</span><span class=nx>p</span><span class=p>,</span> <span class=nx>newlenmem</span><span class=p>),</span> <span class=nx>capmem</span><span class=o>-</span><span class=nx>newlenmem</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 切片中的元素是指针类型
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>p</span> <span class=p>=</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nx>capmem</span><span class=p>,</span> <span class=nx>et</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>lenmem</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>writeBarrier</span><span class=p>.</span><span class=nx>enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 内存屏障
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>bulkBarrierPreWriteSrcOnly</span><span class=p>(</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>p</span><span class=p>),</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>oldPtr</span><span class=p>),</span> <span class=nx>lenmem</span><span class=o>-</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=o>+</span><span class=nx>et</span><span class=p>.</span><span class=nx>ptrdata</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 复制原数组内存中的内容到新申请的内存中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memmove</span><span class=p>(</span><span class=nx>p</span><span class=p>,</span> <span class=nx>oldPtr</span><span class=p>,</span> <span class=nx>lenmem</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>slice</span><span class=p>{</span><span class=nx>p</span><span class=p>,</span> <span class=nx>newLen</span><span class=p>,</span> <span class=nx>newcap</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>此外，<code>nil</code>切片和空切片都是可以通过调用<code>append</code>函数来获得底层数组的扩容，最终都是通过<code>mallocgc</code>来进行内存申请，再赋值给原来的<code>nil</code>切片或空切片，所以<code>nil</code>切片是可以调动<code>append</code>函数的。</p><p>我们用一个常见的例子总结一下扩容的过程</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;len=%d, cap=%d&#34;</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>程序运行结果为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>len</span> <span class=p>=</span> <span class=mi>5</span><span class=p>,</span> <span class=nx>cap</span> <span class=p>=</span> <span class=mi>6</span>
</span></span></code></pre></div><p>在上述代码执行的过程中，我们先初始化了一个长度和容量均为 2 的切片 s ，然后向 s 中追加三个元素，此时就会触发扩容，期望大小为 5，5 大于当前容量的两倍，所以初步计算的 newcap 为 5，在 64
位机器上一个指针的大小为 8 字节，所以期望分配的内存大小为 40 字节。然后要进行内存对齐计算，调用<code>roundupsize</code>进行向上取整，计算结果如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// capmem 计算公式 class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>divRoundUp</span><span class=p>(</span><span class=mi>40</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span> <span class=p>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nx>size_to_class8</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=p>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nx>capmem</span> <span class=p>=</span> <span class=nx>class_to_size</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=p>=</span> <span class=mi>48</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// newcap 计算
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>newcap</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>capmem</span> <span class=o>/</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span><span class=p>)</span> <span class=p>=</span> <span class=mi>48</span><span class=o>/</span><span class=mi>8</span> <span class=p>=</span> <span class=mi>6</span>
</span></span></code></pre></div><p>所以，最终新的 slice 容量为 6.</p><h3 id=拷贝>拷贝<a hidden class=anchor aria-hidden=true href=#拷贝>#</a></h3><p>使用<code>copy</code>函数可以进行切片的拷贝操作，具体实现如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// go 1.20  src/runtime/slice.go
</span></span></span><span class=line><span class=cl><span class=c1>// 元素类型为string 或者 无指针 元素切片copy
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>slicecopy</span><span class=p>(</span><span class=nx>toPtr</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>toLen</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>fromPtr</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>fromLen</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>width</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果长度为0，不需要 copy
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>fromLen</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>toLen</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 记录源切片或者目标切片中较短的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>n</span> <span class=o>:=</span> <span class=nx>fromLen</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>toLen</span> <span class=p>&lt;</span> <span class=nx>n</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span> <span class=p>=</span> <span class=nx>toLen</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 元素类型宽度为0，也不需要执行 copy 操作，直接返回短切片的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>width</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 计算大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>size</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=o>*</span> <span class=nx>width</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>size</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span> <span class=c1>// common case worth about 2x to do here
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// TODO: is this still worth it with new memmove impl?
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 如果 size 大小为1，那么指针直接转换即可
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kt>byte</span><span class=p>)(</span><span class=nx>toPtr</span><span class=p>)</span> <span class=p>=</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kt>byte</span><span class=p>)(</span><span class=nx>fromPtr</span><span class=p>)</span> <span class=c1>// known to be a byte pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 使用 memmove 将 size 大小的内存复制到目标区域 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>memmove</span><span class=p>(</span><span class=nx>toPtr</span><span class=p>,</span> <span class=nx>fromPtr</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=c1>// go 1.20 src/runtime/mbarrier.go
</span></span></span><span class=line><span class=cl><span class=c1>// 指针类型的元素切片 copy
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>typedslicecopy</span><span class=p>(</span><span class=nx>typ</span> <span class=o>*</span><span class=nx>_type</span><span class=p>,</span> <span class=nx>dstPtr</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>dstLen</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>srcPtr</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>srcLen</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// copy 长度计算
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>n</span> <span class=o>:=</span> <span class=nx>dstLen</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=p>&gt;</span> <span class=nx>srcLen</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span> <span class=p>=</span> <span class=nx>srcLen</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>writeBarrier</span><span class=p>.</span><span class=nx>cgo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>cgoCheckSliceCopy</span><span class=p>(</span><span class=nx>typ</span><span class=p>,</span> <span class=nx>dstPtr</span><span class=p>,</span> <span class=nx>srcPtr</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 指针相等，不需要copy了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>dstPtr</span> <span class=o>==</span> <span class=nx>srcPtr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 内存大小计算
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>size</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=o>*</span> <span class=nx>typ</span><span class=p>.</span><span class=nx>size</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>writeBarrier</span><span class=p>.</span><span class=nx>needed</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>pwsize</span> <span class=o>:=</span> <span class=nx>size</span> <span class=o>-</span> <span class=nx>typ</span><span class=p>.</span><span class=nx>size</span> <span class=o>+</span> <span class=nx>typ</span><span class=p>.</span><span class=nx>ptrdata</span>
</span></span><span class=line><span class=cl>        <span class=nf>bulkBarrierPreWrite</span><span class=p>(</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>dstPtr</span><span class=p>),</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>srcPtr</span><span class=p>),</span> <span class=nx>pwsize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 内存 copy
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memmove</span><span class=p>(</span><span class=nx>dstPtr</span><span class=p>,</span> <span class=nx>srcPtr</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上述代码分别是 string 及 元素无指针类型 切片以及指针类型元素切片的拷贝，其实现方法是类似的，即</p><ul><li>拷贝长度为两个切片长度的最小值</li><li>拷贝内容为源切片中对应拷贝长度的整块内存的内容</li><li>返回值为被拷贝的元素的个数</li></ul><p>由此也可以得出，在拷贝的过程中，不会发生扩容。</p><p>此外，在 <code>range</code>遍历的过程中，获得的 value 其实是切片中的值拷贝，并且每次都是拷贝到同一个地址，所以在遍历中拿到的 value 的地址是不变的，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>slice</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>40</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>value</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>slice</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;value = %d , value-addr = %x , slice-addr = %x\n&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>value</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>slice</span><span class=p>[</span><span class=nx>index</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>value</span> <span class=p>=</span> <span class=mi>10</span><span class=p>,</span> <span class=nx>value</span><span class=o>-</span><span class=nx>addr</span> <span class=p>=</span> <span class=mi>14000126008</span><span class=p>,</span> <span class=nx>slice</span><span class=o>-</span><span class=nx>addr</span> <span class=p>=</span> <span class=mf>1400012e000</span>
</span></span><span class=line><span class=cl><span class=nx>value</span> <span class=p>=</span> <span class=mi>20</span><span class=p>,</span> <span class=nx>value</span><span class=o>-</span><span class=nx>addr</span> <span class=p>=</span> <span class=mi>14000126008</span><span class=p>,</span> <span class=nx>slice</span><span class=o>-</span><span class=nx>addr</span> <span class=p>=</span> <span class=mf>1400012e008</span>
</span></span><span class=line><span class=cl><span class=nx>value</span> <span class=p>=</span> <span class=mi>30</span><span class=p>,</span> <span class=nx>value</span><span class=o>-</span><span class=nx>addr</span> <span class=p>=</span> <span class=mi>14000126008</span> <span class=p>,</span> <span class=nx>slice</span><span class=o>-</span><span class=nx>addr</span> <span class=p>=</span> <span class=mf>1400012e010</span>
</span></span><span class=line><span class=cl><span class=nx>value</span> <span class=p>=</span> <span class=mi>40</span> <span class=p>,</span> <span class=nx>value</span><span class=o>-</span><span class=nx>addr</span> <span class=p>=</span> <span class=mi>14000126008</span><span class=p>,</span> <span class=nx>slice</span><span class=o>-</span><span class=nx>addr</span> <span class=p>=</span> <span class=mf>1400012e018</span>
</span></span></code></pre></div><h3 id=参数传递>参数传递<a hidden class=anchor aria-hidden=true href=#参数传递>#</a></h3><p>首先，我们必须明确一点，Go 语言中的函数参数传递，只有值传递，没有引用传递。</p><p>下面我们举几个例子来看看 slice 在函数参数传递中的一些细节。</p><h4 id=slice-和-slice-指针>slice 和 slice 指针<a hidden class=anchor aria-hidden=true href=#slice-和-slice-指针>#</a></h4><p>代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Append</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;param s: %v \n &#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>AppendPtr</span><span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>,</span> <span class=mi>200</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;param *s: %v \n &#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>Append</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;main s1: %v \n &#34;</span><span class=p>,</span> <span class=nx>s1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>s2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>AppendPtr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;main *s2: %v \n &#34;</span><span class=p>,</span> <span class=nx>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>程序运行结果为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>param</span> <span class=nx>s</span><span class=p>:</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>1</span> <span class=mi>1</span> <span class=mi>100</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>main</span> <span class=nx>s1</span><span class=p>:</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>1</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>param</span> <span class=o>*</span><span class=nx>s</span><span class=p>:</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>200</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>main</span> <span class=o>*</span><span class=nx>s2</span><span class=p>:</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>200</span><span class=p>]</span> 
</span></span></code></pre></div><p>可以看出，在<code>Append</code>函数中，参数为 slice 值，所以对参数的变更，并不会影响到外层的 s.</p><p>但是，将 s 指针传入<code>AppendPtr</code>，在函数中对参数做出的改变，是会影响到外层的 s.</p><h4 id=slice-append-操作>slice append 操作<a hidden class=anchor aria-hidden=true href=#slice-append-操作>#</a></h4><p>代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>SliceRise</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>s2</span> <span class=o>:=</span> <span class=nx>s1</span>
</span></span><span class=line><span class=cl>    <span class=nx>s2</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>SliceRise</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>SliceRise</span><span class=p>(</span><span class=nx>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=nx>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>程序运行结果为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>[</span><span class=mi>1</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span><span class=p>]</span>
</span></span></code></pre></div><p>首先，<code>SliceRise()</code>函数中 slice 作为参数，是一个值传递，函数调用时，会拷贝原 slice 的值，对于值的修改不会影响外层的 slice。</p><p>对于 s1 来说，底层数组本身的长度和容量均为2，传递进函数后，进行了 append 操作，这个 append 操作会引发切片的扩容，扩容后会产生一个新的底层数组，这个数组继续赋值给了变量 s。
此时，s1 和 s 指向的底层数组就不一样了，所以 s1 本身和它指向的底层数组，都没有发生任何变化，打印 s1 的结果仍然是 <code>1 2</code>.</p><p>对于 s2 来说，最初 s2 和 s1 指向同一个底层数组，进行 append 操作之后，发生了扩容，并且将 append 之后的新切片赋值给了 s2， 到这里，s1 和 s2 就指向不同的底层数组了。
s2 传递进函数后，进行了 append 操作，这个 append 操作不会引发切片的扩容，这个数组继续赋值给了变量 s。
此时，s2 和 s 依旧共享底层数组，但是s 的长度 len 变成 4 了，而由于函数参数值传递的特点，s2 的长度 len 并不会被改变，所以在进行遍历对元素进行操作之后，
虽然对于 s 和底层数组来说，值变成了<code>2 3 4 1</code>，但是对于 s2 来说，它的长度是 3，所以打印 s2 的结果会是<code>2 3 4</code>.</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><ul><li>数组存储的是一组元素类型相同，存储宽度一致的元素，它们存储在一段连续的内存空间，Go 中的数组是值类型，并且数组大小是固定的。</li><li>切片是对底层数组的一个抽象，表述的是对数组一个连续片段的引用。</li><li>切片结构体中包含了长度，容量以及底层数组地址，多个切片可以共享同一个底层数组。</li><li><code>append</code>函数可以向切片中追加元素，并生成一个新的切片。当切片容量不足的情况下，<code>append</code>函数会先调用<code>growslice</code>进行扩容，然后再进行元素的追加。</li><li>切片扩容后容量的计算分为按照策略计算和内存对齐两部分。扩容后的容量 >= 原容量的两倍 或 1.25倍+192</li><li>切片作为函数参数时是值传递，在函数中操作切片时，可能改变切边中的元素，但是不会改变切片本身。</li></ul><hr><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/>Go 语言设计与实现</a></li><li><a href=https://github.com/RainbowMango/GoExpertProgramming>Go 专家编程</a></li><li><a href=https://qcrao.com/post/dive-into-go-slice/>深度解密 Go 语言之 slice</a></li><li><a href=https://halfrost.com/go_slice/>深入解析 Go 中 Slice 底层实现</a></li><li><a href=https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html>【Go】深入剖析slice和array</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yanhuan0802.github.io/tags/go/>Go</a></li></ul><nav class=paginav><a class=next href=https://yanhuan0802.github.io/posts/packer-qemu-ubuntu2004/><span class=title>Next »</span><br><span>使用 Packer QEMU 插件构建自定义 Ubuntu 20.04 操作系统镜像</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f&amp;hashtags=Go"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f&amp;title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;summary=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;source=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0%20-%20https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on telegram" href="https://telegram.me/share/url?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://giscus.app/client.js data-repo=yanhuan0802/yanhuan0802.github.io data-repo-id=R_kgDOIDpgTQ data-category=Announcements data-category-id=DIC_kwDOIDpgTc4CSYzO data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://yanhuan0802.github.io>YanHuan's World</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>