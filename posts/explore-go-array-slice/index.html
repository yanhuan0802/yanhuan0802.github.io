<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入理解 Go 数组和切片底层实现 | YanHuan's World</title>
<meta name=keywords content="Go"><meta name=description content="数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。"><meta name=author content="YanHuan"><link rel=canonical href=https://yanhuan0802.github.io/posts/explore-go-array-slice/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://yanhuan0802.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yanhuan0802.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yanhuan0802.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yanhuan0802.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yanhuan0802.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yanhuan0802.github.io/posts/explore-go-array-slice/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yanhuan0802.github.io/posts/explore-go-array-slice/"><meta property="og:site_name" content="YanHuan's World"><meta property="og:title" content="深入理解 Go 数组和切片底层实现"><meta property="og:description" content="数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-22T20:33:06+08:00"><meta property="article:modified_time" content="2023-04-24T22:46:49+08:00"><meta property="article:tag" content="Go"><meta property="og:see_also" content="https://yanhuan0802.github.io/posts/go-context/"><meta property="og:see_also" content="https://yanhuan0802.github.io/posts/explore-go-channel/"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入理解 Go 数组和切片底层实现"><meta name=twitter:description content="数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yanhuan0802.github.io/posts/"},{"@type":"ListItem","position":2,"name":"深入理解 Go 数组和切片底层实现","item":"https://yanhuan0802.github.io/posts/explore-go-array-slice/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入理解 Go 数组和切片底层实现","name":"深入理解 Go 数组和切片底层实现","description":"数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。\n","keywords":["Go"],"articleBody":"数组array和切片slice是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。\n本文源码基于 Go 1.20\n数组 数据结构 数组是计算机科学中的一种数据结构，它具有以下几个特点：\n元素类型相同，存储宽度一致 存储在一段连续的内存空间 空间大小固定，不能修改（会出现数据溢出问题） 可以通过元素索引计算出元素的存储地址 几乎所有的计算机语言，对于数组的实现都是相似的，都拥有上述特性，Go语言也一样。\n不同于 C 语言或其他语言，Go 语言数组是值类型，定义的时候就需要指定大小，数组大小是它类型的一部分，不同大小的数组相当于不同的类型，赋值和函数传参都会复制整个数组，相当于是原数组的拷贝。\n初始化 数组有两种初始化的方式，一种是显示声明数组的长度，一种是使用[...]T声明数组。\narr1 := [3]int{0, 1, 2} arr2 := [...]int{0, 1, 2} 第二种初始化的方式属于 Go 语言提供的语法糖，在编译期间就会推导出数组的长度，最终转换成第一种，所以上述两种声明方式在运行期间得到的结果是相同的。\n在编译期间，Go 会根据数组的元素数量，做出如下的优化：\n当元素小于等于4个时，会直接将数组的元素在栈上面初始化； 当元素大于4个时，会将数组在静态区初始化然后复制到栈上面。 缺点 数组大小是固定的，但是很多场景中我们无法直接给出数组的确定长度。\n数组是值类型，传递一个很大的数组给函数会消耗很多内存。\n切片 由于数组的固定长度和值传递不够灵活，所以 Go 语言中，拥有不定长度的引用类型切片（slice）更加常用。\n切片是对数组一个连续片段的引用，这些片段可以是整个数组，或者是由其实和终止索引表示的一些项的子集。\n数据结构 切片的数据结构在源码包中定义\n// src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 其中，array表示指向相关数组的指针，len表示切片长度，cap表示当前切片的容量，即底层数组的大小。其中底层数组是可以被多个 slice 同时指向的，所以对一个 slice 中的元素进行操作，可能也会影响到其他slice.\n由于切片结构体中直接存储了切片的长度和容量，所以内置函数len()和cap()操作的时间复杂度均为O(1).\n切片在运行时的表示:\n// src/reflect/value.go // Deprecated: Use unsafe.Slice or unsafe.SliceData instead. type SliceHeader struct { Data uintptr Len int Cap int } // go 1.20 src/unsafe/unsafe.go // SliceData returns a pointer to the underlying array of the argument // slice. // - If cap(slice) \u003e 0, SliceData returns \u0026slice[:1][0]. // - If slice == nil, SliceData returns nil. // - Otherwise, SliceData returns a non-nil pointer to an // unspecified memory address. func SliceData(slice []ArbitraryType) *ArbitraryType 初始化 变量声明 var s []int 使用这种方式创建出来的 slice 是变量零值，即 nil。它的长度和容量都是 0 ，和nil相等。nil切片可以通过append函数来完成内存申请和元素追加。\n字面量 s1 := []int{} // 空切片 s2 := []int{1, 2} // 长度为3的切片 s3 := []int{0, 1, 2, 3, 8: 100} // 使用索引号直接复制，将索引为 8 位置的元素赋值为 100 其中，空切片指的是切片长度为 0 ，但是值并不是nil，声明长度为 0 的切片时，尽量使用nil切片，这样就不需要进行内存分配。\nmake 函数 s1 := make([]int, 10) // 指定长度，此时容量默认和长度相等 s2 := make([]int, 10, 30) //指定长度和容量 创建时，底层会分配一个数组，数组的长度就是切片的容量。\n创建切片时的运行运行时函数如下：\n// src/runtime/slice.go func makeslice(et *_type, len, cap int) unsafe.Pointer { // 内存空间 = 元素大小 * 切片容量 mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // panic 条件 // 1.内存空间溢出 // 2.申请的内存空间大于最大可分配的内存 // 3.长度小于 0 或大于容量 if overflow || mem \u003e maxAlloc || len \u003c 0 || len \u003e cap { mem, overflow := math.MulUintptr(et.size, uintptr(len)) if overflow || mem \u003e maxAlloc || len \u003c 0 { panicmakeslicelen() } panicmakeslicecap() } // 内存申请：小对象在 P 结构中初始化，大于 32KB 在堆中初始化 return mallocgc(mem, et, true) } 通过下标从数组或切片中切取 s1 := array[1:5] s2 := sourceSlice[1:5] 使用下标初始化不会复制原数组或者原切片中的数据，只会创建一个指向原数组的结构体，数组后面的内容都作为切片的预留内存。 同时，slice 将和原数组共用一部分内存，对数组或slice元素的修改，都会影响到彼此。如果因为执行append操作使得新的 slice 底层数组扩容，移动到了新的位置，那么两者就不会互相影响了。\n追加和扩容 追加 使用 append函数可以向切片中追加元素：\nfunc append(slice []Type, elems ...Type) []Type append函数的参数长度可变，所以可以追加多个值到 slice 中，还可以用 ...传入 slice，直接追加一个切片。\ns1 = append(s1, 1, 2, 3) s1 = append(s1, s2...) append函数返回值是一个新的 slice，可以选择覆盖原 slice，也可以选择定义赋值给新的 slice，但是 Go 编译器不允许调用了 append函数后不使用返回值。\n扩容 使用append向 slice 中追加元素，实际上是向底层数组添加元素，如果 slice 底层数组空间不足，就会触发 slice 扩容。\n扩容就是为切片分配新的内存空间并复制原切片中元素的过程。新的底层数组长度大于原有的 slice 底层数组，这样就可以进行append操作，具体的扩容策略如下：\n// src/runtime/slice.go func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice { ... // 扩容策略 newcap := oldCap doublecap := newcap + newcap if newLen \u003e doublecap { // 期望大小大于当前容量的两倍，使用期望大小 newcap = newLen } else { // 期望大小小于当前容量的两倍 const threshold = 256 if oldCap \u003c threshold { // 原容量小于 256 ，容量翻倍 newcap = doublecap } else { // 原容量大于256 // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. // 保证 newcap \u003e newLen for 0 \u003c newcap \u0026\u0026 newcap \u003c newLen { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. // 每次增加 25% + 192，比 Go1.18 之前更加平滑 newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. // 溢出情况处理 if newcap \u003c= 0 { newcap = newLen } } } ... } 在运行时，根据新长度的大小，选择了不同的策略进行扩容：\n如果期望大小大于当前容量的两倍，新容量就会使用期望大小 否则判断，如果旧切片的容量小于 256，新容量就会是旧容量的两倍 否则判断，如果旧切片的容量大于256，新容量就会使用从旧容量开始循环增加，每次增加25% + 192，直到新容量大于等于新长度。 如果新容量计算溢出了，就使用新长度作为新容量。 这个扩容策略是在 Go 1.18 开始执行的，相比 Go 1.18 之前使用 1024 作为扩容基准值，这个策略则更加平滑。\n经过上述策略，得到的新容量只能说是一个大致容量，最终的容量和内存大小，还需要根据切片中的元素大小进行内存对齐。具体内存对齐代码如下所示：\n// src/runtime/slice.go func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice { ... // 新长度及容量大小计算，根据切片中元素大小进行内存对齐 var overflow bool var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don't need any division/multiplication. // For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. switch { case et.size == 1: lenmem = uintptr(oldLen) newlenmem = uintptr(newLen) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) \u003e maxAlloc newcap = int(capmem) case et.size == goarch.PtrSize: lenmem = uintptr(oldLen) * goarch.PtrSize newlenmem = uintptr(newLen) * goarch.PtrSize capmem = roundupsize(uintptr(newcap) * goarch.PtrSize) overflow = uintptr(newcap) \u003e maxAlloc/goarch.PtrSize newcap = int(capmem / goarch.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if goarch.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.TrailingZeros64(uint64(et.size))) \u0026 63 } else { shift = uintptr(sys.TrailingZeros32(uint32(et.size))) \u0026 31 } lenmem = uintptr(oldLen) \u003c\u003c shift newlenmem = uintptr(newLen) \u003c\u003c shift capmem = roundupsize(uintptr(newcap) \u003c\u003c shift) overflow = uintptr(newcap) \u003e (maxAlloc \u003e\u003e shift) newcap = int(capmem \u003e\u003e shift) capmem = uintptr(newcap) \u003c\u003c shift default: lenmem = uintptr(oldLen) * et.size newlenmem = uintptr(newLen) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) capmem = uintptr(newcap) * et.size } ... } // src/runtime/msize.go func roundupsize(size uintptr) uintptr { if size \u003c _MaxSmallSize { if size \u003c= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } if size+_PageSize \u003c size { return size } return alignUp(size, _PageSize) } // src/runtime/sizeclass.go const ( _MaxSmallSize = 32768 smallSizeDiv = 8 smallSizeMax = 1024 largeSizeDiv = 128 _NumSizeClasses = 68 _PageShift = 13 ) // 这是 Go 源码中有关内存分配的 slice。 // class_to_size 通过 spanClass获取 span划分的 object大小。 // 而 size_to_class8 size_to_class128 表示通过 size 获取它的 spanClass var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32} var size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + 1]uint8{32, 33, 34, 35, 36, 37, 37, 38, 38, 39, 39, 40, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67} // src/runtime/stubs.go func divRoundUp(n, a uintptr) uintptr { // a is generally a power of two. This will get inlined and // the compiler will optimize the division. return (n + a - 1) / a } rounddupsize函数会将待申请的内存向上取整，取整时会使用class_to_size数组，提高了内存分配效率并减少碎片。\n接下来，就是进行内存分配，复制数据，append元素到新的底层数组。\n// src/runtime/slice.go func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice { ... // 计算内存溢出 if overflow || capmem \u003e maxAlloc { panic(errorString(\"growslice: len out of range\")) } var p unsafe.Pointer if et.ptrdata == 0 { // 切片中的元素不是指针类型 // 分配内存 p = mallocgc(capmem, nil, false) // 清除不会覆盖的部分 memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem) } else { // 切片中的元素是指针类型 // 分配内存 p = mallocgc(capmem, et, true) if lenmem \u003e 0 \u0026\u0026 writeBarrier.enabled { // 内存屏障 bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(oldPtr), lenmem-et.size+et.ptrdata) } } // 复制原数组内存中的内容到新申请的内存中 memmove(p, oldPtr, lenmem) return slice{p, newLen, newcap} } 此外，nil切片和空切片都是可以通过调用append函数来获得底层数组的扩容，最终都是通过mallocgc来进行内存申请，再赋值给原来的nil切片或空切片，所以nil切片是可以调动append函数的。\n我们用一个常见的例子总结一下扩容的过程\nfunc main() { s := []int{1, 2} s = append(s, 3, 4, 5) fmt.Printf(\"len=%d, cap=%d\",len(s), cap(s)) } 程序运行结果为：\nlen = 5, cap = 6 在上述代码执行的过程中，我们先初始化了一个长度和容量均为 2 的切片 s ，然后向 s 中追加三个元素，此时就会触发扩容，期望大小为 5，5 大于当前容量的两倍，所以初步计算的 newcap 为 5，在 64 位机器上一个指针的大小为 8 字节，所以期望分配的内存大小为 40 字节。然后要进行内存对齐计算，调用roundupsize进行向上取整，计算结果如下所示：\n// capmem 计算公式 class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]] divRoundUp(40, 8) = 5 size_to_class8[5] = 5 capmem = class_to_size[5] = 48 // newcap 计算 newcap = int(capmem / goarch.PtrSize) = 48/8 = 6 所以，最终新的 slice 容量为 6.\n拷贝 使用copy函数可以进行切片的拷贝操作，具体实现如下所示：\n// src/runtime/slice.go // 元素类型为string 或者 无指针 元素切片copy func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int { // 如果长度为0，不需要 copy if fromLen == 0 || toLen == 0 { return 0 } // 记录源切片或者目标切片中较短的长度 n := fromLen if toLen \u003c n { n = toLen } // 元素类型宽度为0，也不需要执行 copy 操作，直接返回短切片的长度 if width == 0 { return n } // 计算大小 size := uintptr(n) * width ... if size == 1 { // common case worth about 2x to do here // TODO: is this still worth it with new memmove impl? // 如果 size 大小为1，那么指针直接转换即可 *(*byte)(toPtr) = *(*byte)(fromPtr) // known to be a byte pointer } else { // 使用 memmove 将 size 大小的内存复制到目标区域 memmove(toPtr, fromPtr, size) } return n } // src/runtime/mbarrier.go // 指针类型的元素切片 copy func typedslicecopy(typ *_type, dstPtr unsafe.Pointer, dstLen int, srcPtr unsafe.Pointer, srcLen int) int { // copy 长度计算 n := dstLen if n \u003e srcLen { n = srcLen } if n == 0 { return 0 } ... if writeBarrier.cgo { cgoCheckSliceCopy(typ, dstPtr, srcPtr, n) } // 指针相等，不需要copy了 if dstPtr == srcPtr { return n } // 内存大小计算 size := uintptr(n) * typ.size if writeBarrier.needed { pwsize := size - typ.size + typ.ptrdata bulkBarrierPreWrite(uintptr(dstPtr), uintptr(srcPtr), pwsize) } // 内存 copy memmove(dstPtr, srcPtr, size) return n } 上述代码分别是 string 及 元素无指针类型 切片以及指针类型元素切片的拷贝，其实现方法是类似的，即\n拷贝长度为两个切片长度的最小值 拷贝内容为源切片中对应拷贝长度的整块内存的内容 返回值为被拷贝的元素的个数 由此也可以得出，在拷贝的过程中，不会发生扩容。\n此外，在 range遍历的过程中，获得的 value 其实是切片中的值拷贝，并且每次都是拷贝到同一个地址，所以在遍历中拿到的 value 的地址是不变的，如下所示：\nfunc main() { slice := []int{10, 20, 30, 40} for index, value := range slice { fmt.Printf(\"value = %d , value-addr = %x , slice-addr = %x\\n\", value, \u0026value, \u0026slice[index]) } } 输出结果：\nvalue = 10, value-addr = 14000126008, slice-addr = 1400012e000 value = 20, value-addr = 14000126008, slice-addr = 1400012e008 value = 30, value-addr = 14000126008 , slice-addr = 1400012e010 value = 40 , value-addr = 14000126008, slice-addr = 1400012e018 参数传递 首先，我们必须明确一点，Go 语言中的函数参数传递，只有值传递，没有引用传递。\n下面我们举几个例子来看看 slice 在函数参数传递中的一些细节。\nslice 和 slice 指针 代码示例：\nfunc Append(s []int) { s = append(s, 100) fmt.Printf(\"param s: %v \\n \", s) } func AppendPtr(s *[]int) { *s = append(*s, 200) fmt.Printf(\"param *s: %v \\n \", *s) } func main() { s1 := []int{1, 1, 1} Append(s1) fmt.Printf(\"main s1: %v \\n \", s1) s2 := []int{1, 2, 3} AppendPtr(\u0026s2) fmt.Printf(\"main *s2: %v \\n \", s2) } 程序运行结果为：\nparam s: [1 1 1 100] main s1: [1 1 1] param *s: [1 2 3 200] main *s2: [1 2 3 200] 可以看出，在Append函数中，参数为 slice 值，所以对参数的变更，并不会影响到外层的 s.\n但是，将 s 指针传入AppendPtr，在函数中对参数做出的改变，是会影响到外层的 s.\nslice append 操作 代码示例：\nfunc SliceRise(s []int) { s = append(s, 0) for i := range s { s[i]++ } } func main() { s1 := []int{1, 2} s2 := s1 s2 = append(s2, 3) SliceRise(s1) SliceRise(s2) fmt.Println(s1, s2) } 程序运行结果为：\n[1 2] [2 3 4] 首先，SliceRise()函数中 slice 作为参数，是一个值传递，函数调用时，会拷贝原 slice 的值，对于值的修改不会影响外层的 slice。\n对于 s1 来说，底层数组本身的长度和容量均为2，传递进函数后，进行了 append 操作，这个 append 操作会引发切片的扩容，扩容后会产生一个新的底层数组，这个数组继续赋值给了变量 s。 此时，s1 和 s 指向的底层数组就不一样了，所以 s1 本身和它指向的底层数组，都没有发生任何变化，打印 s1 的结果仍然是 1 2.\n对于 s2 来说，最初 s2 和 s1 指向同一个底层数组，进行 append 操作之后，发生了扩容，并且将 append 之后的新切片赋值给了 s2， 到这里，s1 和 s2 就指向不同的底层数组了。 s2 传递进函数后，进行了 append 操作，这个 append 操作不会引发切片的扩容，这个数组继续赋值给了变量 s。 此时，s2 和 s 依旧共享底层数组，但是s 的长度 len 变成 4 了，而由于函数参数值传递的特点，s2 的长度 len 并不会被改变，所以在进行遍历对元素进行操作之后， 虽然对于 s 和底层数组来说，值变成了2 3 4 1，但是对于 s2 来说，它的长度是 3，所以打印 s2 的结果会是2 3 4.\n总结 数组存储的是一组元素类型相同，存储宽度一致的元素，它们存储在一段连续的内存空间，Go 中的数组是值类型，并且数组大小是固定的。 切片是对底层数组的一个抽象，表述的是对数组一个连续片段的引用。 切片结构体中包含了长度，容量以及底层数组地址，多个切片可以共享同一个底层数组。 append函数可以向切片中追加元素，并生成一个新的切片。当切片容量不足的情况下，append函数会先调用growslice进行扩容，然后再进行元素的追加。 切片扩容后容量的计算分为按照策略计算和内存对齐两部分。扩容后的容量 \u003e= 原容量的两倍 或 1.25倍。 切片作为函数参数时是值传递，在函数中操作切片时，可能改变切边中的元素，但是不会改变切片本身。 参考资料 Go 语言设计与实现 Go 专家编程 深度解密 Go 语言之 slice 深入解析 Go 中 Slice 底层实现 【Go】深入剖析slice和array ","wordCount":"5578","inLanguage":"en","datePublished":"2023-04-22T20:33:06+08:00","dateModified":"2023-04-24T22:46:49+08:00","author":{"@type":"Person","name":"YanHuan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yanhuan0802.github.io/posts/explore-go-array-slice/"},"publisher":{"@type":"Organization","name":"YanHuan's World","logo":{"@type":"ImageObject","url":"https://yanhuan0802.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yanhuan0802.github.io/ accesskey=h title="YanHuan's World (Alt + H)">YanHuan's World</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yanhuan0802.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://yanhuan0802.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yanhuan0802.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yanhuan0802.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yanhuan0802.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">深入理解 Go 数组和切片底层实现</h1><div class=post-meta><span title='2023-04-22 20:33:06 +0800 CST'>April 22, 2023</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;5578 words&nbsp;·&nbsp;YanHuan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#数组>数组</a><ul><li><a href=#数据结构>数据结构</a></li><li><a href=#初始化>初始化</a></li><li><a href=#缺点>缺点</a></li></ul></li><li><a href=#切片>切片</a><ul><li><a href=#数据结构-1>数据结构</a></li><li><a href=#初始化-1>初始化</a></li><li><a href=#追加和扩容>追加和扩容</a></li><li><a href=#拷贝>拷贝</a></li><li><a href=#参数传递>参数传递</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div><div class=post-content><p>数组<code>array</code>和切片<code>slice</code>是 Go 语言的两种基本数据结构，也是我们需要深入了解的基础概念。在本篇文章中，我们将深入探讨 Go 语言的数组和切片实现原理，帮助大家更好地理解它们的使用方法和优劣势。</p><blockquote><p>本文源码基于 Go 1.20</p></blockquote><h2 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h2><h3 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h3><p>数组是计算机科学中的一种数据结构，它具有以下几个特点：</p><ul><li>元素类型相同，存储宽度一致</li><li>存储在一段连续的内存空间</li><li>空间大小固定，不能修改（会出现数据溢出问题）</li><li>可以通过元素索引计算出元素的存储地址</li></ul><p>几乎所有的计算机语言，对于数组的实现都是相似的，都拥有上述特性，Go语言也一样。</p><p>不同于 C 语言或其他语言，Go 语言数组是值类型，定义的时候就需要指定大小，数组大小是它类型的一部分，不同大小的数组相当于不同的类型，赋值和函数传参都会复制整个数组，相当于是原数组的拷贝。</p><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><p>数组有两种初始化的方式，一种是显示声明数组的长度，一种是使用<code>[...]T</code>声明数组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>arr1 <span style=color:#ff79c6>:=</span> [<span style=color:#bd93f9>3</span>]<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>}
</span></span><span style=display:flex><span>arr2 <span style=color:#ff79c6>:=</span> [<span style=color:#ff79c6>...</span>]<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>}
</span></span></code></pre></div><p>第二种初始化的方式属于 Go 语言提供的语法糖，在编译期间就会推导出数组的长度，最终转换成第一种，所以上述两种声明方式在运行期间得到的结果是相同的。</p><p>在编译期间，Go 会根据数组的元素数量，做出如下的优化：</p><ul><li>当元素小于等于4个时，会直接将数组的元素在栈上面初始化；</li><li>当元素大于4个时，会将数组在静态区初始化然后复制到栈上面。</li></ul><h3 id=缺点>缺点<a hidden class=anchor aria-hidden=true href=#缺点>#</a></h3><p>数组大小是固定的，但是很多场景中我们无法直接给出数组的确定长度。</p><p>数组是值类型，传递一个很大的数组给函数会消耗很多内存。</p><h2 id=切片>切片<a hidden class=anchor aria-hidden=true href=#切片>#</a></h2><p>由于数组的固定长度和值传递不够灵活，所以 Go 语言中，拥有不定长度的引用类型切片（slice）更加常用。</p><p>切片是对数组一个连续片段的引用，这些片段可以是整个数组，或者是由其实和终止索引表示的一些项的子集。</p><h3 id=数据结构-1>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构-1>#</a></h3><p>切片的数据结构在源码包中定义</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/slice.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> slice <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    array unsafe.Pointer <span style=color:#6272a4>// 元素指针
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    len   <span style=color:#8be9fd>int</span> <span style=color:#6272a4>// 长度
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    cap   <span style=color:#8be9fd>int</span> <span style=color:#6272a4>// 容量
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>其中，<code>array</code>表示指向相关数组的指针，<code>len</code>表示切片长度，<code>cap</code>表示当前切片的容量，即底层数组的大小。其中底层数组是可以被多个 slice 同时指向的，所以对一个 slice 中的元素进行操作，可能也会影响到其他slice.</p><p>由于切片结构体中直接存储了切片的长度和容量，所以内置函数<code>len()</code>和<code>cap()</code>操作的时间复杂度均为<code>O(1)</code>.</p><p>切片在运行时的表示:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/reflect/value.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Deprecated: Use unsafe.Slice or unsafe.SliceData instead.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> SliceHeader <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    Data <span style=color:#8be9fd>uintptr</span>
</span></span><span style=display:flex><span>    Len  <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>    Cap  <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// go 1.20 src/unsafe/unsafe.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// SliceData returns a pointer to the underlying array of the argument
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// slice.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - If cap(slice) &gt; 0, SliceData returns &amp;slice[:1][0].
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - If slice == nil, SliceData returns nil.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - Otherwise, SliceData returns a non-nil pointer to an
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     unspecified memory address.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>SliceData</span>(slice []ArbitraryType) <span style=color:#ff79c6>*</span>ArbitraryType
</span></span></code></pre></div><h3 id=初始化-1>初始化<a hidden class=anchor aria-hidden=true href=#初始化-1>#</a></h3><ul><li>变量声明</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>var</span> s []<span style=color:#8be9fd>int</span>
</span></span></code></pre></div><p>使用这种方式创建出来的 slice 是变量零值，即 <code>nil</code>。它的长度和容量都是 0 ，和<code>nil</code>相等。<code>nil</code>切片可以通过<code>append</code>函数来完成内存申请和元素追加。</p><ul><li>字面量</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>s1 <span style=color:#ff79c6>:=</span> []<span style=color:#8be9fd>int</span>{}                   <span style=color:#6272a4>// 空切片
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>s2 <span style=color:#ff79c6>:=</span> []<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>}               <span style=color:#6272a4>// 长度为3的切片
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>s3 <span style=color:#ff79c6>:=</span> []<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>8</span>: <span style=color:#bd93f9>100</span>} <span style=color:#6272a4>// 使用索引号直接复制，将索引为 8 位置的元素赋值为 100
</span></span></span></code></pre></div><p>其中，空切片指的是切片长度为 0 ，但是值并不是<code>nil</code>，声明长度为 0 的切片时，尽量使用<code>nil</code>切片，这样就不需要进行内存分配。</p><ul><li>make 函数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>s1 <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>([]<span style=color:#8be9fd>int</span>, <span style=color:#bd93f9>10</span>) <span style=color:#6272a4>// 指定长度，此时容量默认和长度相等
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>s2 <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>([]<span style=color:#8be9fd>int</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>30</span>) <span style=color:#6272a4>//指定长度和容量
</span></span></span></code></pre></div><p>创建时，底层会分配一个数组，数组的长度就是切片的容量。</p><p>创建切片时的运行运行时函数如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/slice.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>makeslice</span>(et <span style=color:#ff79c6>*</span>_type, len, cap <span style=color:#8be9fd>int</span>) unsafe.Pointer {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 内存空间 = 元素大小 * 切片容量
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    mem, overflow <span style=color:#ff79c6>:=</span> math.<span style=color:#50fa7b>MulUintptr</span>(et.size, <span style=color:#8be9fd;font-style:italic>uintptr</span>(cap))
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// panic 条件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 1.内存空间溢出
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 2.申请的内存空间大于最大可分配的内存
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 3.长度小于 0 或大于容量
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> overflow <span style=color:#ff79c6>||</span> mem &gt; maxAlloc <span style=color:#ff79c6>||</span> len &lt; <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>||</span> len &gt; cap {
</span></span><span style=display:flex><span>        mem, overflow <span style=color:#ff79c6>:=</span> math.<span style=color:#50fa7b>MulUintptr</span>(et.size, <span style=color:#8be9fd;font-style:italic>uintptr</span>(len))
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> overflow <span style=color:#ff79c6>||</span> mem &gt; maxAlloc <span style=color:#ff79c6>||</span> len &lt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#50fa7b>panicmakeslicelen</span>()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>panicmakeslicecap</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 内存申请：小对象在 P 结构中初始化，大于 32KB 在堆中初始化
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>mallocgc</span>(mem, et, <span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>通过下标从数组或切片中切取</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>s1 <span style=color:#ff79c6>:=</span> array[<span style=color:#bd93f9>1</span>:<span style=color:#bd93f9>5</span>]
</span></span><span style=display:flex><span>s2 <span style=color:#ff79c6>:=</span> sourceSlice[<span style=color:#bd93f9>1</span>:<span style=color:#bd93f9>5</span>]
</span></span></code></pre></div><p>使用下标初始化不会复制原数组或者原切片中的数据，只会创建一个指向原数组的结构体，数组后面的内容都作为切片的预留内存。
同时，slice 将和原数组共用一部分内存，对数组或slice元素的修改，都会影响到彼此。如果因为执行<code>append</code>操作使得新的 slice 底层数组扩容，移动到了新的位置，那么两者就不会互相影响了。</p><h3 id=追加和扩容>追加和扩容<a hidden class=anchor aria-hidden=true href=#追加和扩容>#</a></h3><h4 id=追加>追加<a hidden class=anchor aria-hidden=true href=#追加>#</a></h4><p>使用 <code>append</code>函数可以向切片中追加元素：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#8be9fd;font-style:italic>append</span>(slice []Type, elems <span style=color:#ff79c6>...</span>Type) []Type
</span></span></code></pre></div><p><code>append</code>函数的参数长度可变，所以可以追加多个值到 slice 中，还可以用 <code>...</code>传入 slice，直接追加一个切片。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>s1 = <span style=color:#8be9fd;font-style:italic>append</span>(s1, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>s1 = <span style=color:#8be9fd;font-style:italic>append</span>(s1, s2<span style=color:#ff79c6>...</span>)
</span></span></code></pre></div><p><code>append</code>函数返回值是一个新的 slice，可以选择覆盖原 slice，也可以选择定义赋值给新的 slice，但是 Go 编译器不允许调用了 <code>append</code>函数后不使用返回值。</p><h4 id=扩容>扩容<a hidden class=anchor aria-hidden=true href=#扩容>#</a></h4><p>使用<code>append</code>向 slice 中追加元素，实际上是向底层数组添加元素，如果 slice 底层数组空间不足，就会触发 slice 扩容。</p><p>扩容就是为切片分配新的内存空间并复制原切片中元素的过程。新的底层数组长度大于原有的 slice 底层数组，这样就可以进行<code>append</code>操作，具体的扩容策略如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/slice.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>growslice</span>(oldPtr unsafe.Pointer, newLen, oldCap, num <span style=color:#8be9fd>int</span>, et <span style=color:#ff79c6>*</span>_type) slice {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 扩容策略
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    newcap <span style=color:#ff79c6>:=</span> oldCap
</span></span><span style=display:flex><span>    doublecap <span style=color:#ff79c6>:=</span> newcap <span style=color:#ff79c6>+</span> newcap
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> newLen &gt; doublecap {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 期望大小大于当前容量的两倍，使用期望大小
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        newcap = newLen
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 期望大小小于当前容量的两倍
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#8be9fd;font-style:italic>const</span> threshold = <span style=color:#bd93f9>256</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> oldCap &lt; threshold {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 原容量小于 256 ，容量翻倍
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        newcap = doublecap
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 原容量大于256
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// Check 0 &lt; newcap to detect overflow
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// and prevent an infinite loop.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// 保证 newcap &gt; newLen
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>for</span> <span style=color:#bd93f9>0</span> &lt; newcap <span style=color:#ff79c6>&amp;&amp;</span> newcap &lt; newLen {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// Transition from growing 2x for small slices
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                <span style=color:#6272a4>// to growing 1.25x for large slices. This formula
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                <span style=color:#6272a4>// gives a smooth-ish transition between the two.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 每次增加 25% + 192，比 Go1.18 之前更加平滑
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                newcap <span style=color:#ff79c6>+=</span> (newcap <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>3</span><span style=color:#ff79c6>*</span>threshold) <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>4</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Set newcap to the requested cap when
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// the newcap calculation overflowed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// 溢出情况处理
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>if</span> newcap <span style=color:#ff79c6>&lt;=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>                newcap = newLen
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在运行时，根据新长度的大小，选择了不同的策略进行扩容：</p><ul><li>如果期望大小大于当前容量的两倍，新容量就会使用期望大小</li><li>否则判断，如果旧切片的容量小于 256，新容量就会是旧容量的两倍</li><li>否则判断，如果旧切片的容量大于256，新容量就会使用从旧容量开始循环增加，每次增加<code>25% + 192</code>，直到新容量大于等于新长度。</li><li>如果新容量计算溢出了，就使用新长度作为新容量。</li></ul><p>这个扩容策略是在 Go 1.18 开始执行的，相比 Go 1.18 之前使用 1024 作为扩容基准值，这个策略则更加平滑。</p><p>经过上述策略，得到的新容量只能说是一个大致容量，最终的容量和内存大小，还需要根据切片中的元素大小进行内存对齐。具体内存对齐代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/slice.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>growslice</span>(oldPtr unsafe.Pointer, newLen, oldCap, num <span style=color:#8be9fd>int</span>, et <span style=color:#ff79c6>*</span>_type) slice {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 新长度及容量大小计算，根据切片中元素大小进行内存对齐
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd;font-style:italic>var</span> overflow <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> lenmem, newlenmem, capmem <span style=color:#8be9fd>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Specialize for common values of et.size.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// For 1 we don&#39;t need any division/multiplication.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// For powers of 2, use a variable shift.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>switch</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>case</span> et.size <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span>:
</span></span><span style=display:flex><span>        lenmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(oldLen)
</span></span><span style=display:flex><span>        newlenmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newLen)
</span></span><span style=display:flex><span>        capmem = <span style=color:#50fa7b>roundupsize</span>(<span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap))
</span></span><span style=display:flex><span>        overflow = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap) &gt; maxAlloc
</span></span><span style=display:flex><span>        newcap = <span style=color:#8be9fd;font-style:italic>int</span>(capmem)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>case</span> et.size <span style=color:#ff79c6>==</span> goarch.PtrSize:
</span></span><span style=display:flex><span>        lenmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(oldLen) <span style=color:#ff79c6>*</span> goarch.PtrSize
</span></span><span style=display:flex><span>        newlenmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newLen) <span style=color:#ff79c6>*</span> goarch.PtrSize
</span></span><span style=display:flex><span>        capmem = <span style=color:#50fa7b>roundupsize</span>(<span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap) <span style=color:#ff79c6>*</span> goarch.PtrSize)
</span></span><span style=display:flex><span>        overflow = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap) &gt; maxAlloc<span style=color:#ff79c6>/</span>goarch.PtrSize
</span></span><span style=display:flex><span>        newcap = <span style=color:#8be9fd;font-style:italic>int</span>(capmem <span style=color:#ff79c6>/</span> goarch.PtrSize)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>case</span> <span style=color:#50fa7b>isPowerOfTwo</span>(et.size):
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>var</span> shift <span style=color:#8be9fd>uintptr</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> goarch.PtrSize <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>8</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Mask shift for better code generation.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            shift = <span style=color:#8be9fd;font-style:italic>uintptr</span>(sys.<span style=color:#50fa7b>TrailingZeros64</span>(<span style=color:#8be9fd;font-style:italic>uint64</span>(et.size))) <span style=color:#ff79c6>&amp;</span> <span style=color:#bd93f9>63</span>
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            shift = <span style=color:#8be9fd;font-style:italic>uintptr</span>(sys.<span style=color:#50fa7b>TrailingZeros32</span>(<span style=color:#8be9fd;font-style:italic>uint32</span>(et.size))) <span style=color:#ff79c6>&amp;</span> <span style=color:#bd93f9>31</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        lenmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(oldLen) <span style=color:#ff79c6>&lt;&lt;</span> shift
</span></span><span style=display:flex><span>        newlenmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newLen) <span style=color:#ff79c6>&lt;&lt;</span> shift
</span></span><span style=display:flex><span>        capmem = <span style=color:#50fa7b>roundupsize</span>(<span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap) <span style=color:#ff79c6>&lt;&lt;</span> shift)
</span></span><span style=display:flex><span>        overflow = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap) &gt; (maxAlloc <span style=color:#ff79c6>&gt;&gt;</span> shift)
</span></span><span style=display:flex><span>        newcap = <span style=color:#8be9fd;font-style:italic>int</span>(capmem <span style=color:#ff79c6>&gt;&gt;</span> shift)
</span></span><span style=display:flex><span>        capmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap) <span style=color:#ff79c6>&lt;&lt;</span> shift
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>default</span>:
</span></span><span style=display:flex><span>        lenmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(oldLen) <span style=color:#ff79c6>*</span> et.size
</span></span><span style=display:flex><span>        newlenmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newLen) <span style=color:#ff79c6>*</span> et.size
</span></span><span style=display:flex><span>        capmem, overflow = math.<span style=color:#50fa7b>MulUintptr</span>(et.size, <span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap))
</span></span><span style=display:flex><span>        capmem = <span style=color:#50fa7b>roundupsize</span>(capmem)
</span></span><span style=display:flex><span>        newcap = <span style=color:#8be9fd;font-style:italic>int</span>(capmem <span style=color:#ff79c6>/</span> et.size)
</span></span><span style=display:flex><span>        capmem = <span style=color:#8be9fd;font-style:italic>uintptr</span>(newcap) <span style=color:#ff79c6>*</span> et.size
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/runtime/msize.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>roundupsize</span>(size <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>uintptr</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> size &lt; _MaxSmallSize {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> size <span style=color:#ff79c6>&lt;=</span> smallSizeMax<span style=color:#ff79c6>-</span><span style=color:#bd93f9>8</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(class_to_size[size_to_class8[<span style=color:#50fa7b>divRoundUp</span>(size, smallSizeDiv)]])
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(class_to_size[size_to_class128[<span style=color:#50fa7b>divRoundUp</span>(size<span style=color:#ff79c6>-</span>smallSizeMax, largeSizeDiv)]])
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> size<span style=color:#ff79c6>+</span>_PageSize &lt; size {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> size
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>alignUp</span>(size, _PageSize)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/runtime/sizeclass.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>const</span> (
</span></span><span style=display:flex><span>    _MaxSmallSize = <span style=color:#bd93f9>32768</span>
</span></span><span style=display:flex><span>    smallSizeDiv = <span style=color:#bd93f9>8</span>
</span></span><span style=display:flex><span>    smallSizeMax = <span style=color:#bd93f9>1024</span>
</span></span><span style=display:flex><span>    largeSizeDiv = <span style=color:#bd93f9>128</span>
</span></span><span style=display:flex><span>    _NumSizeClasses = <span style=color:#bd93f9>68</span>
</span></span><span style=display:flex><span>    _PageShift = <span style=color:#bd93f9>13</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这是 Go 源码中有关内存分配的 slice。
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// class_to_size 通过 spanClass获取 span划分的 object大小。
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 而 size_to_class8  size_to_class128 表示通过 size 获取它的 spanClass
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> class_to_size = [_NumSizeClasses]<span style=color:#8be9fd>uint16</span>{<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>16</span>, <span style=color:#bd93f9>24</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>48</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>80</span>, <span style=color:#bd93f9>96</span>, <span style=color:#bd93f9>112</span>, <span style=color:#bd93f9>128</span>, <span style=color:#bd93f9>144</span>, <span style=color:#bd93f9>160</span>, <span style=color:#bd93f9>176</span>, <span style=color:#bd93f9>192</span>, <span style=color:#bd93f9>208</span>, <span style=color:#bd93f9>224</span>, <span style=color:#bd93f9>240</span>, <span style=color:#bd93f9>256</span>, <span style=color:#bd93f9>288</span>, <span style=color:#bd93f9>320</span>, <span style=color:#bd93f9>352</span>, <span style=color:#bd93f9>384</span>, <span style=color:#bd93f9>416</span>, <span style=color:#bd93f9>448</span>, <span style=color:#bd93f9>480</span>, <span style=color:#bd93f9>512</span>, <span style=color:#bd93f9>576</span>, <span style=color:#bd93f9>640</span>, <span style=color:#bd93f9>704</span>, <span style=color:#bd93f9>768</span>, <span style=color:#bd93f9>896</span>, <span style=color:#bd93f9>1024</span>, <span style=color:#bd93f9>1152</span>, <span style=color:#bd93f9>1280</span>, <span style=color:#bd93f9>1408</span>, <span style=color:#bd93f9>1536</span>, <span style=color:#bd93f9>1792</span>, <span style=color:#bd93f9>2048</span>, <span style=color:#bd93f9>2304</span>, <span style=color:#bd93f9>2688</span>, <span style=color:#bd93f9>3072</span>, <span style=color:#bd93f9>3200</span>, <span style=color:#bd93f9>3456</span>, <span style=color:#bd93f9>4096</span>, <span style=color:#bd93f9>4864</span>, <span style=color:#bd93f9>5376</span>, <span style=color:#bd93f9>6144</span>, <span style=color:#bd93f9>6528</span>, <span style=color:#bd93f9>6784</span>, <span style=color:#bd93f9>6912</span>, <span style=color:#bd93f9>8192</span>, <span style=color:#bd93f9>9472</span>, <span style=color:#bd93f9>9728</span>, <span style=color:#bd93f9>10240</span>, <span style=color:#bd93f9>10880</span>, <span style=color:#bd93f9>12288</span>, <span style=color:#bd93f9>13568</span>, <span style=color:#bd93f9>14336</span>, <span style=color:#bd93f9>16384</span>, <span style=color:#bd93f9>18432</span>, <span style=color:#bd93f9>19072</span>, <span style=color:#bd93f9>20480</span>, <span style=color:#bd93f9>21760</span>, <span style=color:#bd93f9>24576</span>, <span style=color:#bd93f9>27264</span>, <span style=color:#bd93f9>28672</span>, <span style=color:#bd93f9>32768</span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>var</span> size_to_class8 = [smallSizeMax<span style=color:#ff79c6>/</span>smallSizeDiv <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>]<span style=color:#8be9fd>uint8</span>{<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>, <span style=color:#bd93f9>11</span>, <span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>, <span style=color:#bd93f9>15</span>, <span style=color:#bd93f9>16</span>, <span style=color:#bd93f9>16</span>, <span style=color:#bd93f9>17</span>, <span style=color:#bd93f9>17</span>, <span style=color:#bd93f9>18</span>, <span style=color:#bd93f9>18</span>, <span style=color:#bd93f9>19</span>, <span style=color:#bd93f9>19</span>, <span style=color:#bd93f9>19</span>, <span style=color:#bd93f9>19</span>, <span style=color:#bd93f9>20</span>, <span style=color:#bd93f9>20</span>, <span style=color:#bd93f9>20</span>, <span style=color:#bd93f9>20</span>, <span style=color:#bd93f9>21</span>, <span style=color:#bd93f9>21</span>, <span style=color:#bd93f9>21</span>, <span style=color:#bd93f9>21</span>, <span style=color:#bd93f9>22</span>, <span style=color:#bd93f9>22</span>, <span style=color:#bd93f9>22</span>, <span style=color:#bd93f9>22</span>, <span style=color:#bd93f9>23</span>, <span style=color:#bd93f9>23</span>, <span style=color:#bd93f9>23</span>, <span style=color:#bd93f9>23</span>, <span style=color:#bd93f9>24</span>, <span style=color:#bd93f9>24</span>, <span style=color:#bd93f9>24</span>, <span style=color:#bd93f9>24</span>, <span style=color:#bd93f9>25</span>, <span style=color:#bd93f9>25</span>, <span style=color:#bd93f9>25</span>, <span style=color:#bd93f9>25</span>, <span style=color:#bd93f9>26</span>, <span style=color:#bd93f9>26</span>, <span style=color:#bd93f9>26</span>, <span style=color:#bd93f9>26</span>, <span style=color:#bd93f9>27</span>, <span style=color:#bd93f9>27</span>, <span style=color:#bd93f9>27</span>, <span style=color:#bd93f9>27</span>, <span style=color:#bd93f9>27</span>, <span style=color:#bd93f9>27</span>, <span style=color:#bd93f9>27</span>, <span style=color:#bd93f9>27</span>, <span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>29</span>, <span style=color:#bd93f9>29</span>, <span style=color:#bd93f9>29</span>, <span style=color:#bd93f9>29</span>, <span style=color:#bd93f9>29</span>, <span style=color:#bd93f9>29</span>, <span style=color:#bd93f9>29</span>, <span style=color:#bd93f9>29</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>31</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>32</span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>var</span> size_to_class128 = [(_MaxSmallSize<span style=color:#ff79c6>-</span>smallSizeMax)<span style=color:#ff79c6>/</span>largeSizeDiv <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>]<span style=color:#8be9fd>uint8</span>{<span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>33</span>, <span style=color:#bd93f9>34</span>, <span style=color:#bd93f9>35</span>, <span style=color:#bd93f9>36</span>, <span style=color:#bd93f9>37</span>, <span style=color:#bd93f9>37</span>, <span style=color:#bd93f9>38</span>, <span style=color:#bd93f9>38</span>, <span style=color:#bd93f9>39</span>, <span style=color:#bd93f9>39</span>, <span style=color:#bd93f9>40</span>, <span style=color:#bd93f9>40</span>, <span style=color:#bd93f9>40</span>, <span style=color:#bd93f9>41</span>, <span style=color:#bd93f9>41</span>, <span style=color:#bd93f9>41</span>, <span style=color:#bd93f9>42</span>, <span style=color:#bd93f9>43</span>, <span style=color:#bd93f9>43</span>, <span style=color:#bd93f9>44</span>, <span style=color:#bd93f9>44</span>, <span style=color:#bd93f9>44</span>, <span style=color:#bd93f9>44</span>, <span style=color:#bd93f9>44</span>, <span style=color:#bd93f9>45</span>, <span style=color:#bd93f9>45</span>, <span style=color:#bd93f9>45</span>, <span style=color:#bd93f9>45</span>, <span style=color:#bd93f9>45</span>, <span style=color:#bd93f9>45</span>, <span style=color:#bd93f9>46</span>, <span style=color:#bd93f9>46</span>, <span style=color:#bd93f9>46</span>, <span style=color:#bd93f9>46</span>, <span style=color:#bd93f9>47</span>, <span style=color:#bd93f9>47</span>, <span style=color:#bd93f9>47</span>, <span style=color:#bd93f9>47</span>, <span style=color:#bd93f9>47</span>, <span style=color:#bd93f9>47</span>, <span style=color:#bd93f9>48</span>, <span style=color:#bd93f9>48</span>, <span style=color:#bd93f9>48</span>, <span style=color:#bd93f9>49</span>, <span style=color:#bd93f9>49</span>, <span style=color:#bd93f9>50</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>51</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>52</span>, <span style=color:#bd93f9>53</span>, <span style=color:#bd93f9>53</span>, <span style=color:#bd93f9>54</span>, <span style=color:#bd93f9>54</span>, <span style=color:#bd93f9>54</span>, <span style=color:#bd93f9>54</span>, <span style=color:#bd93f9>55</span>, <span style=color:#bd93f9>55</span>, <span style=color:#bd93f9>55</span>, <span style=color:#bd93f9>55</span>, <span style=color:#bd93f9>55</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>56</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>57</span>, <span style=color:#bd93f9>58</span>, <span style=color:#bd93f9>58</span>, <span style=color:#bd93f9>58</span>, <span style=color:#bd93f9>58</span>, <span style=color:#bd93f9>58</span>, <span style=color:#bd93f9>58</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>59</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>60</span>, <span style=color:#bd93f9>61</span>, <span style=color:#bd93f9>61</span>, <span style=color:#bd93f9>61</span>, <span style=color:#bd93f9>61</span>, <span style=color:#bd93f9>61</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>62</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>63</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>65</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>66</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>, <span style=color:#bd93f9>67</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/runtime/stubs.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>divRoundUp</span>(n, a <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>uintptr</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// a is generally a power of two. This will get inlined and
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// the compiler will optimize the division.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> (n <span style=color:#ff79c6>+</span> a <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>/</span> a
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>rounddupsize</code>函数会将待申请的内存向上取整，取整时会使用<code>class_to_size</code>数组，提高了内存分配效率并减少碎片。</p><p>接下来，就是进行内存分配，复制数据，<code>append</code>元素到新的底层数组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/slice.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>growslice</span>(oldPtr unsafe.Pointer, newLen, oldCap, num <span style=color:#8be9fd>int</span>, et <span style=color:#ff79c6>*</span>_type) slice {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 计算内存溢出
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> overflow <span style=color:#ff79c6>||</span> capmem &gt; maxAlloc {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>errorString</span>(<span style=color:#f1fa8c>&#34;growslice: len out of range&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> p unsafe.Pointer
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> et.ptrdata <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 切片中的元素不是指针类型
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>// 分配内存
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        p = <span style=color:#50fa7b>mallocgc</span>(capmem, <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>false</span>)
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 清除不会覆盖的部分
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#50fa7b>memclrNoHeapPointers</span>(<span style=color:#50fa7b>add</span>(p, newlenmem), capmem<span style=color:#ff79c6>-</span>newlenmem)
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 切片中的元素是指针类型
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>// 分配内存
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        p = <span style=color:#50fa7b>mallocgc</span>(capmem, et, <span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> lenmem &gt; <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> writeBarrier.enabled {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 内存屏障
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#50fa7b>bulkBarrierPreWriteSrcOnly</span>(<span style=color:#8be9fd;font-style:italic>uintptr</span>(p), <span style=color:#8be9fd;font-style:italic>uintptr</span>(oldPtr), lenmem<span style=color:#ff79c6>-</span>et.size<span style=color:#ff79c6>+</span>et.ptrdata)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 复制原数组内存中的内容到新申请的内存中
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>memmove</span>(p, oldPtr, lenmem)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> slice{p, newLen, newcap}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此外，<code>nil</code>切片和空切片都是可以通过调用<code>append</code>函数来获得底层数组的扩容，最终都是通过<code>mallocgc</code>来进行内存申请，再赋值给原来的<code>nil</code>切片或空切片，所以<code>nil</code>切片是可以调动<code>append</code>函数的。</p><p>我们用一个常见的例子总结一下扩容的过程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    s <span style=color:#ff79c6>:=</span> []<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>}
</span></span><span style=display:flex><span>    s = <span style=color:#8be9fd;font-style:italic>append</span>(s, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>)
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;len=%d, cap=%d&#34;</span>,<span style=color:#8be9fd;font-style:italic>len</span>(s), <span style=color:#8be9fd;font-style:italic>cap</span>(s))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>程序运行结果为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>len = <span style=color:#bd93f9>5</span>, cap = <span style=color:#bd93f9>6</span>
</span></span></code></pre></div><p>在上述代码执行的过程中，我们先初始化了一个长度和容量均为 2 的切片 s ，然后向 s 中追加三个元素，此时就会触发扩容，期望大小为 5，5 大于当前容量的两倍，所以初步计算的 newcap 为 5，在 64
位机器上一个指针的大小为 8 字节，所以期望分配的内存大小为 40 字节。然后要进行内存对齐计算，调用<code>roundupsize</code>进行向上取整，计算结果如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// capmem 计算公式 class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#50fa7b>divRoundUp</span>(<span style=color:#bd93f9>40</span>, <span style=color:#bd93f9>8</span>) = <span style=color:#bd93f9>5</span>
</span></span><span style=display:flex><span>size_to_class8[<span style=color:#bd93f9>5</span>] = <span style=color:#bd93f9>5</span>
</span></span><span style=display:flex><span>capmem = class_to_size[<span style=color:#bd93f9>5</span>] = <span style=color:#bd93f9>48</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// newcap 计算
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>newcap = <span style=color:#8be9fd;font-style:italic>int</span>(capmem <span style=color:#ff79c6>/</span> goarch.PtrSize) = <span style=color:#bd93f9>48</span><span style=color:#ff79c6>/</span><span style=color:#bd93f9>8</span> = <span style=color:#bd93f9>6</span>
</span></span></code></pre></div><p>所以，最终新的 slice 容量为 6.</p><h3 id=拷贝>拷贝<a hidden class=anchor aria-hidden=true href=#拷贝>#</a></h3><p>使用<code>copy</code>函数可以进行切片的拷贝操作，具体实现如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// src/runtime/slice.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 元素类型为string 或者 无指针 元素切片copy
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>slicecopy</span>(toPtr unsafe.Pointer, toLen <span style=color:#8be9fd>int</span>, fromPtr unsafe.Pointer, fromLen <span style=color:#8be9fd>int</span>, width <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果长度为0，不需要 copy
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> fromLen <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>||</span> toLen <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 记录源切片或者目标切片中较短的长度
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    n <span style=color:#ff79c6>:=</span> fromLen
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> toLen &lt; n {
</span></span><span style=display:flex><span>        n = toLen
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 元素类型宽度为0，也不需要执行 copy 操作，直接返回短切片的长度
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> width <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> n
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 计算大小
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    size <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(n) <span style=color:#ff79c6>*</span> width
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> size <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span> { <span style=color:#6272a4>// common case worth about 2x to do here
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>// TODO: is this still worth it with new memmove impl?
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>// 如果 size 大小为1，那么指针直接转换即可
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>*</span>(<span style=color:#ff79c6>*</span><span style=color:#8be9fd>byte</span>)(toPtr) = <span style=color:#ff79c6>*</span>(<span style=color:#ff79c6>*</span><span style=color:#8be9fd>byte</span>)(fromPtr) <span style=color:#6272a4>// known to be a byte pointer
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 使用 memmove 将 size 大小的内存复制到目标区域 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#50fa7b>memmove</span>(toPtr, fromPtr, size)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> n
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#6272a4>// src/runtime/mbarrier.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 指针类型的元素切片 copy
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>typedslicecopy</span>(typ <span style=color:#ff79c6>*</span>_type, dstPtr unsafe.Pointer, dstLen <span style=color:#8be9fd>int</span>, srcPtr unsafe.Pointer, srcLen <span style=color:#8be9fd>int</span>) <span style=color:#8be9fd>int</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// copy 长度计算
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    n <span style=color:#ff79c6>:=</span> dstLen
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> n &gt; srcLen {
</span></span><span style=display:flex><span>        n = srcLen
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> writeBarrier.cgo {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>cgoCheckSliceCopy</span>(typ, dstPtr, srcPtr, n)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 指针相等，不需要copy了
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> dstPtr <span style=color:#ff79c6>==</span> srcPtr {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> n
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 内存大小计算
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    size <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(n) <span style=color:#ff79c6>*</span> typ.size
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> writeBarrier.needed {
</span></span><span style=display:flex><span>        pwsize <span style=color:#ff79c6>:=</span> size <span style=color:#ff79c6>-</span> typ.size <span style=color:#ff79c6>+</span> typ.ptrdata
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>bulkBarrierPreWrite</span>(<span style=color:#8be9fd;font-style:italic>uintptr</span>(dstPtr), <span style=color:#8be9fd;font-style:italic>uintptr</span>(srcPtr), pwsize)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 内存 copy
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>memmove</span>(dstPtr, srcPtr, size)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> n
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述代码分别是 string 及 元素无指针类型 切片以及指针类型元素切片的拷贝，其实现方法是类似的，即</p><ul><li>拷贝长度为两个切片长度的最小值</li><li>拷贝内容为源切片中对应拷贝长度的整块内存的内容</li><li>返回值为被拷贝的元素的个数</li></ul><p>由此也可以得出，在拷贝的过程中，不会发生扩容。</p><p>此外，在 <code>range</code>遍历的过程中，获得的 value 其实是切片中的值拷贝，并且每次都是拷贝到同一个地址，所以在遍历中拿到的 value 的地址是不变的，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    slice <span style=color:#ff79c6>:=</span> []<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>20</span>, <span style=color:#bd93f9>30</span>, <span style=color:#bd93f9>40</span>}
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> index, value <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> slice {
</span></span><span style=display:flex><span>        fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;value = %d , value-addr = %x , slice-addr = %x\n&#34;</span>, value, <span style=color:#ff79c6>&amp;</span>value, <span style=color:#ff79c6>&amp;</span>slice[index])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>value = <span style=color:#bd93f9>10</span>, value<span style=color:#ff79c6>-</span>addr = <span style=color:#bd93f9>14000126008</span>, slice<span style=color:#ff79c6>-</span>addr = <span style=color:#bd93f9>1400012e000</span>
</span></span><span style=display:flex><span>value = <span style=color:#bd93f9>20</span>, value<span style=color:#ff79c6>-</span>addr = <span style=color:#bd93f9>14000126008</span>, slice<span style=color:#ff79c6>-</span>addr = <span style=color:#bd93f9>1400012e008</span>
</span></span><span style=display:flex><span>value = <span style=color:#bd93f9>30</span>, value<span style=color:#ff79c6>-</span>addr = <span style=color:#bd93f9>14000126008</span> , slice<span style=color:#ff79c6>-</span>addr = <span style=color:#bd93f9>1400012e010</span>
</span></span><span style=display:flex><span>value = <span style=color:#bd93f9>40</span> , value<span style=color:#ff79c6>-</span>addr = <span style=color:#bd93f9>14000126008</span>, slice<span style=color:#ff79c6>-</span>addr = <span style=color:#bd93f9>1400012e018</span>
</span></span></code></pre></div><h3 id=参数传递>参数传递<a hidden class=anchor aria-hidden=true href=#参数传递>#</a></h3><p>首先，我们必须明确一点，Go 语言中的函数参数传递，只有值传递，没有引用传递。</p><p>下面我们举几个例子来看看 slice 在函数参数传递中的一些细节。</p><h4 id=slice-和-slice-指针>slice 和 slice 指针<a hidden class=anchor aria-hidden=true href=#slice-和-slice-指针>#</a></h4><p>代码示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>Append</span>(s []<span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>    s = <span style=color:#8be9fd;font-style:italic>append</span>(s, <span style=color:#bd93f9>100</span>)
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;param s: %v \n &#34;</span>, s)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>AppendPtr</span>(s <span style=color:#ff79c6>*</span>[]<span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>*</span>s = <span style=color:#8be9fd;font-style:italic>append</span>(<span style=color:#ff79c6>*</span>s, <span style=color:#bd93f9>200</span>)
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;param *s: %v \n &#34;</span>, <span style=color:#ff79c6>*</span>s)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    s1 <span style=color:#ff79c6>:=</span> []<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>1</span>}
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Append</span>(s1)
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;main s1: %v \n &#34;</span>, s1)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    s2 <span style=color:#ff79c6>:=</span> []<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>}
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>AppendPtr</span>(<span style=color:#ff79c6>&amp;</span>s2)
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;main *s2: %v \n &#34;</span>, s2)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>程序运行结果为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>param s: [<span style=color:#bd93f9>1</span> <span style=color:#bd93f9>1</span> <span style=color:#bd93f9>1</span> <span style=color:#bd93f9>100</span>]
</span></span><span style=display:flex><span>main s1: [<span style=color:#bd93f9>1</span> <span style=color:#bd93f9>1</span> <span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>param <span style=color:#ff79c6>*</span>s: [<span style=color:#bd93f9>1</span> <span style=color:#bd93f9>2</span> <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>200</span>]
</span></span><span style=display:flex><span>main <span style=color:#ff79c6>*</span>s2: [<span style=color:#bd93f9>1</span> <span style=color:#bd93f9>2</span> <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>200</span>] 
</span></span></code></pre></div><p>可以看出，在<code>Append</code>函数中，参数为 slice 值，所以对参数的变更，并不会影响到外层的 s.</p><p>但是，将 s 指针传入<code>AppendPtr</code>，在函数中对参数做出的改变，是会影响到外层的 s.</p><h4 id=slice-append-操作>slice append 操作<a hidden class=anchor aria-hidden=true href=#slice-append-操作>#</a></h4><p>代码示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>SliceRise</span>(s []<span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>    s = <span style=color:#8be9fd;font-style:italic>append</span>(s, <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> s {
</span></span><span style=display:flex><span>        s[i]<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    s1 <span style=color:#ff79c6>:=</span> []<span style=color:#8be9fd>int</span>{<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>}
</span></span><span style=display:flex><span>    s2 <span style=color:#ff79c6>:=</span> s1
</span></span><span style=display:flex><span>    s2 = <span style=color:#8be9fd;font-style:italic>append</span>(s2, <span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>SliceRise</span>(s1)
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>SliceRise</span>(s2)
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Println</span>(s1, s2)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>程序运行结果为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>[<span style=color:#bd93f9>1</span> <span style=color:#bd93f9>2</span>] [<span style=color:#bd93f9>2</span> <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>4</span>]
</span></span></code></pre></div><p>首先，<code>SliceRise()</code>函数中 slice 作为参数，是一个值传递，函数调用时，会拷贝原 slice 的值，对于值的修改不会影响外层的 slice。</p><p>对于 s1 来说，底层数组本身的长度和容量均为2，传递进函数后，进行了 append 操作，这个 append 操作会引发切片的扩容，扩容后会产生一个新的底层数组，这个数组继续赋值给了变量 s。
此时，s1 和 s 指向的底层数组就不一样了，所以 s1 本身和它指向的底层数组，都没有发生任何变化，打印 s1 的结果仍然是 <code>1 2</code>.</p><p>对于 s2 来说，最初 s2 和 s1 指向同一个底层数组，进行 append 操作之后，发生了扩容，并且将 append 之后的新切片赋值给了 s2， 到这里，s1 和 s2 就指向不同的底层数组了。
s2 传递进函数后，进行了 append 操作，这个 append 操作不会引发切片的扩容，这个数组继续赋值给了变量 s。
此时，s2 和 s 依旧共享底层数组，但是s 的长度 len 变成 4 了，而由于函数参数值传递的特点，s2 的长度 len 并不会被改变，所以在进行遍历对元素进行操作之后，
虽然对于 s 和底层数组来说，值变成了<code>2 3 4 1</code>，但是对于 s2 来说，它的长度是 3，所以打印 s2 的结果会是<code>2 3 4</code>.</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><ul><li>数组存储的是一组元素类型相同，存储宽度一致的元素，它们存储在一段连续的内存空间，Go 中的数组是值类型，并且数组大小是固定的。</li><li>切片是对底层数组的一个抽象，表述的是对数组一个连续片段的引用。</li><li>切片结构体中包含了长度，容量以及底层数组地址，多个切片可以共享同一个底层数组。</li><li><code>append</code>函数可以向切片中追加元素，并生成一个新的切片。当切片容量不足的情况下，<code>append</code>函数会先调用<code>growslice</code>进行扩容，然后再进行元素的追加。</li><li>切片扩容后容量的计算分为按照策略计算和内存对齐两部分。扩容后的容量 >= 原容量的两倍 或 1.25倍。</li><li>切片作为函数参数时是值传递，在函数中操作切片时，可能改变切边中的元素，但是不会改变切片本身。</li></ul><hr><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/>Go 语言设计与实现</a></li><li><a href=https://github.com/RainbowMango/GoExpertProgramming>Go 专家编程</a></li><li><a href=https://qcrao.com/post/dive-into-go-slice/>深度解密 Go 语言之 slice</a></li><li><a href=https://halfrost.com/go_slice/>深入解析 Go 中 Slice 底层实现</a></li><li><a href=https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html>【Go】深入剖析slice和array</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yanhuan0802.github.io/tags/go/>Go</a></li></ul><nav class=paginav><a class=prev href=https://yanhuan0802.github.io/posts/explore-go-channel/><span class=title>« Prev</span><br><span>深入理解 Go Channel 底层实现</span>
</a><a class=next href=https://yanhuan0802.github.io/posts/packer-qemu-ubuntu2004/><span class=title>Next »</span><br><span>使用 Packer QEMU 插件构建自定义 Ubuntu 20.04 OS 镜像</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on x" href="https://x.com/intent/tweet/?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f&amp;hashtags=Go"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f&amp;title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;summary=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;source=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0%20-%20https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on telegram" href="https://telegram.me/share/url?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 深入理解 Go 数组和切片底层实现 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Go%20%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0&u=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fexplore-go-array-slice%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=yanhuan0802/yanhuan0802.github.io data-repo-id=R_kgDOIDpgTQ data-category=Announcements data-category-id=DIC_kwDOIDpgTc4CSYzO data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://yanhuan0802.github.io/>YanHuan's World</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>