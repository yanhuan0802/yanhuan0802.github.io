<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>跨平台构建多 CPU 架构容器镜像 | YanHuan's World</title>
<meta name=keywords content="Docker,ARM,x86"><meta name=description content="docker 容器镜像"><meta name=author content="YanHuan"><link rel=canonical href=https://yanhuan0802.github.io/posts/multi-arch-images/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://yanhuan0802.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yanhuan0802.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yanhuan0802.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yanhuan0802.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yanhuan0802.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yanhuan0802.github.io/posts/multi-arch-images/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yanhuan0802.github.io/posts/multi-arch-images/"><meta property="og:site_name" content="YanHuan's World"><meta property="og:title" content="跨平台构建多 CPU 架构容器镜像"><meta property="og:description" content="docker 容器镜像"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-17T10:43:24+08:00"><meta property="article:modified_time" content="2023-09-17T10:53:09+08:00"><meta property="article:tag" content="Docker"><meta property="article:tag" content="ARM"><meta property="article:tag" content="X86"><meta name=twitter:card content="summary"><meta name=twitter:title content="跨平台构建多 CPU 架构容器镜像"><meta name=twitter:description content="docker 容器镜像"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yanhuan0802.github.io/posts/"},{"@type":"ListItem","position":2,"name":"跨平台构建多 CPU 架构容器镜像","item":"https://yanhuan0802.github.io/posts/multi-arch-images/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"跨平台构建多 CPU 架构容器镜像","name":"跨平台构建多 CPU 架构容器镜像","description":"docker 容器镜像","keywords":["Docker","ARM","x86"],"articleBody":"背景 在国产化和信创的潮流下，应用程序容器镜像支持多 CPU 架构的需求已经很普遍。常见的做法是为不同平台单独构建一个版本，或者分别构建不同架构的镜像再利用 docker manifest 的能力来做镜像合并 。当用来开发的平台与部署的目标平台不同时，实现这一目标并不容易，例如在 x86 架构上开发一个应用程序并将其部署到 ARM 平台的机器上，通常需要准备 ARM 平台的基础设施用于编译打包。在这个场景下，一次构建多处部署的必要性就比较高了，在没有一个成熟的 CI 流水线的情况下，利用 docker buildx 构建跨平台的镜像也是一种比较高效的解决方案。 前置知识 镜像 Registry 对多系统架构镜像的支持 目前大部分镜像托管平台（如 dockerhub、各个公有云的容器镜像服务以及开源镜像仓库工具 harbor）都支持多系统架构镜像，以下图 dockerhub 平台的 golang 镜像为例，单个镜像 tag golang:latest 就包含了 10 种不同系统架构的镜像。 Docker 对多系统架构镜像的管理 Docker 使用 manifest 组来管理多 CPU 架构的镜像，manifest 是一个 JSON 文件，指容器镜像的元数据文件，一个 manifest 对应一个镜像 tag 下一个CPU 架构的镜像。 一个 manifest 组的文件并不直接表示镜像信息，而是使用了一个列表指向了该清单中包含的多份子清单文件，每一份子清单文件均表示一种架构的镜像清单。 查看一个镜像的manifest 列表 docker manifest inspect golang:latest 结果： 多系统架构镜像的使用 我们通过 docker pull 或者 docker run 进行镜像的拉取或使用时，docker 会自动拉取匹配当前系统架构的镜像。\n# 镜像拉取 docker pull golang:latest # 镜像 manifest 查看 docker inspect golang:latest # 只看 CPU 架构 docker inspect golang:latest | grep Architecture ARM 平台 linux X86 平台 Docker Buildx 简介 buildx 是一个 Docker CLI 插件，用于使用 BuildKit 扩展构建功能。使用 docker buildx CLI 插件可以轻松构建多系统架构 Docker 镜像。 版本要求 在 Docker Engine 19.03 及以上版本，可以安装和使用 buildx 插件，低版本 Docker Engine 可能会出现兼容性的问题。 安装 Windows 或者 MacOS 参考 Docker Buildx 默认包含在适用于 Windows 和 macOS 的 Docker Desktop 中 。 Linux 参考 Docker Engine 安装文档，Docker Engine 软件包存储库包含 Docker Buildx 软件包，安装 docker-buildx-plugin 包以安装 Buildx 插件。 # centos sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin # ubuntu sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin 启用 binfmt_misc binfmt_misc 是 Linux 内核的一个模块，全称是混杂二进制格式的内核支持(Kernel Support for miscellaneous Binary Formats) ，它允许用户在 Linux 系统上注册一些特定格式的二进制文件，并指定相应的解释器进行解释和执行。 这些注册的文件类型可以是任何格式，例如 Windows 可执行文件、Java 类文件或 Python 脚本等，而解释器可以是任何可执行程序，例如 shell、Python 解释器或者 Java 虚拟机等。通过 binfmt_misc，用户可以在 Linux 系统上方便地运行各种不同的二进制文件，从而提高了系统的灵活性和可用性。\nDocker Desktop 版本不需要执行此项，默认就是启用的。\ndocker run --privileged --rm docker/binfmt:a7996909642ee92942dcd6cff44b9b95f08dad64 验证 docker buildx version # 输出示例：github.com/docker/buildx v0.11.2-desktop.1 986ab6afe790e25f022969a18bc0111cff170bc2 多架构镜像构建 构建器 builder docker buildx 通过 builder 实例对象来管理构建配置和节点，命令行将构建任务发送至 builder 实例，再由 builder 指派给符合条件的节点执行。\n我们可以基于同一个 docker 服务程序创建多个 builder 实例，提供给不同的项目使用以隔离各个项目的配置。\n查看构建器列表 docker buildx ls # 在结果列表中可以看到目前使用的构建器及其支持的架构，如果目前使用的构建器支持我们需要的架构，则不需要创建新的构建器 # 示例 mybuilder * docker-container mybuilder0 unix:///var/run/docker.sock running linux/arm64, linux/amd64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6 default docker default default running linux/amd64, linux/386 创建新的构建器 docker buildx create --use --name mybuilder 检查和启动 docker buildx inspect mybuilder --bootstrap 镜像构建 Dockerfile 示例 FROM nginx:latest CMD [\"nginx\", \"-g\", \"daemon off;\"] 进入 Dockerfile 所在目录，执行如下示例的命令，就可以构建自己指定的架构版本镜像并推送到当前用户的dockerhub 镜像仓库。 docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7 -t yanhuan6252/nginx:v1 --push . 构建结果示例 原理 buildx 通过 QEMU 和 binfmt_misc 分别为 不同的 CPU 架构构建不同的镜像。构建完成后，就会创建一个 manifest list ，其中包含了指向这几个镜像的指针，当在不同的架构环境使用时会根据其环境拉取相应架构的镜像。 缺点 构建速度比较慢，效率比较低。 只能推送到镜像仓库后在查看和使用，没办法构建到本地。 没办法构建复杂镜像，比如说 MySQL 这种，安装时要 copy 不同架构的 rpm 包到镜像中，用这种方法就实现不了，还是得使用两个 Dockerfile 分别构建镜像，然后再合并manifest list 的方法来实现。 更适合个人/小团队开发测试使用，企业级使用的话最好还是使用内部流水线或者 github action 这种自动化程度更高的工具来完成。 参考资料 buildx buildkit buildx build QEMU binfmt_misc ","wordCount":"1640","inLanguage":"en","datePublished":"2023-09-17T10:43:24+08:00","dateModified":"2023-09-17T10:53:09+08:00","author":{"@type":"Person","name":"YanHuan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yanhuan0802.github.io/posts/multi-arch-images/"},"publisher":{"@type":"Organization","name":"YanHuan's World","logo":{"@type":"ImageObject","url":"https://yanhuan0802.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yanhuan0802.github.io/ accesskey=h title="YanHuan's World (Alt + H)">YanHuan's World</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yanhuan0802.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://yanhuan0802.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yanhuan0802.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yanhuan0802.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yanhuan0802.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">跨平台构建多 CPU 架构容器镜像</h1><div class=post-description>docker 容器镜像</div><div class=post-meta><span title='2023-09-17 10:43:24 +0800 CST'>September 17, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;1640 words&nbsp;·&nbsp;YanHuan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#前置知识>前置知识</a><ul><li><a href=#镜像-registry-对多系统架构镜像的支持>镜像 Registry 对多系统架构镜像的支持</a></li><li><a href=#docker-对多系统架构镜像的管理>Docker 对多系统架构镜像的管理</a></li><li><a href=#多系统架构镜像的使用>多系统架构镜像的使用</a></li></ul></li><li><a href=#docker-buildx>Docker Buildx</a><ul><li><a href=#简介>简介</a></li><li><a href=#安装>安装</a></li><li><a href=#多架构镜像构建>多架构镜像构建</a></li><li><a href=#原理>原理</a></li><li><a href=#缺点>缺点</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div><div class=post-content><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><ul><li>在国产化和信创的潮流下，应用程序容器镜像支持多 CPU 架构的需求已经很普遍。常见的做法是为不同平台单独构建一个版本，或者分别构建不同架构的镜像再利用
<code>docker manifest</code> 的能力来做镜像合并 。当用来开发的平台与部署的目标平台不同时，实现这一目标并不容易，例如在 x86
架构上开发一个应用程序并将其部署到 ARM 平台的机器上，通常需要准备 ARM 平台的基础设施用于编译打包。在这个场景下，一次构建多处部署的必要性就比较高了，在没有一个成熟的
CI 流水线的情况下，利用 <code>docker buildx</code> 构建跨平台的镜像也是一种比较高效的解决方案。</li></ul><h2 id=前置知识>前置知识<a hidden class=anchor aria-hidden=true href=#前置知识>#</a></h2><h3 id=镜像-registry-对多系统架构镜像的支持>镜像 Registry 对多系统架构镜像的支持<a hidden class=anchor aria-hidden=true href=#镜像-registry-对多系统架构镜像的支持>#</a></h3><p>目前大部分镜像托管平台（如 dockerhub、各个公有云的容器镜像服务以及开源镜像仓库工具 harbor）都支持多系统架构镜像，以下图
dockerhub 平台的 <code>golang</code> 镜像为例，单个镜像 tag <code>golang:latest</code> 就包含了 10 种不同系统架构的镜像。
<img alt=go_image loading=lazy src=/img/go-image.png></p><h3 id=docker-对多系统架构镜像的管理>Docker 对多系统架构镜像的管理<a hidden class=anchor aria-hidden=true href=#docker-对多系统架构镜像的管理>#</a></h3><ul><li>Docker 使用 <code>manifest</code> 组来管理多 CPU 架构的镜像，<code>manifest</code> 是一个 JSON 文件，指容器镜像的元数据文件，一个 <code>manifest</code>
对应一个镜像 tag 下一个CPU 架构的镜像。</li><li>一个 <code>manifest</code> 组的文件并不直接表示镜像信息，而是使用了一个列表指向了该清单中包含的多份子清单文件，每一份子清单文件均表示一种架构的镜像清单。</li><li>查看一个镜像的manifest 列表</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker manifest inspect golang:latest
</span></span></code></pre></div><p>结果：
<img alt="go image manifest" loading=lazy src=/img/go-image-manifest.png></p><h3 id=多系统架构镜像的使用>多系统架构镜像的使用<a hidden class=anchor aria-hidden=true href=#多系统架构镜像的使用>#</a></h3><p>我们通过 <code>docker pull</code> 或者 <code>docker run</code> 进行镜像的拉取或使用时，docker 会自动拉取匹配当前系统架构的镜像。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 镜像拉取</span>
</span></span><span style=display:flex><span>docker pull golang:latest
</span></span><span style=display:flex><span><span style=color:#6272a4># 镜像 manifest 查看</span>
</span></span><span style=display:flex><span>docker inspect golang:latest
</span></span><span style=display:flex><span><span style=color:#6272a4># 只看 CPU 架构</span>
</span></span><span style=display:flex><span>docker inspect golang:latest | grep Architecture
</span></span></code></pre></div><ul><li>ARM 平台
<img alt="go image arm" loading=lazy src=/img/go-image-arm.png></li><li>linux X86 平台
<img alt="go image x86" loading=lazy src=/img/go-image-x86.png></li></ul><h2 id=docker-buildx>Docker Buildx<a hidden class=anchor aria-hidden=true href=#docker-buildx>#</a></h2><h3 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h3><ul><li><code>buildx</code> 是一个 Docker CLI 插件，用于使用 <a href=https://github.com/moby/buildkit>BuildKit</a> 扩展构建功能。使用
<code>docker buildx</code> CLI 插件可以轻松构建多系统架构 Docker 镜像。</li></ul><h4 id=版本要求>版本要求<a hidden class=anchor aria-hidden=true href=#版本要求>#</a></h4><ul><li>在 <code>Docker Engine 19.03</code> 及以上版本，可以安装和使用 <code>buildx</code> 插件，低版本 Docker Engine 可能会出现兼容性的问题。</li></ul><h3 id=安装>安装<a hidden class=anchor aria-hidden=true href=#安装>#</a></h3><h4 id=windows-或者-macos>Windows 或者 MacOS<a hidden class=anchor aria-hidden=true href=#windows-或者-macos>#</a></h4><ul><li>参考 <code>Docker Buildx</code> 默认包含在适用于 Windows 和 macOS 的 Docker Desktop 中 。</li></ul><h4 id=linux>Linux<a hidden class=anchor aria-hidden=true href=#linux>#</a></h4><ul><li>参考 <a href=https://docs.docker.com/engine/installl/>Docker Engine 安装文档</a>，<code>Docker Engine</code> 软件包存储库包含
<code>Docker Buildx</code> 软件包，安装 docker-buildx-plugin 包以安装 Buildx 插件。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># centos</span>
</span></span><span style=display:flex><span>sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin 
</span></span><span style=display:flex><span><span style=color:#6272a4># ubuntu</span>
</span></span><span style=display:flex><span>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin 
</span></span></code></pre></div><ul><li>启用 <code>binfmt_misc</code></li></ul><blockquote><p>binfmt_misc 是 Linux 内核的一个模块，全称是混杂二进制格式的内核支持(Kernel Support for miscellaneous Binary Formats)
，它允许用户在 Linux 系统上注册一些特定格式的二进制文件，并指定相应的解释器进行解释和执行。
这些注册的文件类型可以是任何格式，例如 Windows 可执行文件、Java 类文件或 Python 脚本等，而解释器可以是任何可执行程序，例如
shell、Python 解释器或者 Java 虚拟机等。通过 binfmt_misc，用户可以在 Linux 系统上方便地运行各种不同的二进制文件，从而提高了系统的灵活性和可用性。</p></blockquote><blockquote><p>Docker Desktop 版本不需要执行此项，默认就是启用的。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run --privileged --rm docker/binfmt:a7996909642ee92942dcd6cff44b9b95f08dad64
</span></span></code></pre></div><h4 id=验证>验证<a hidden class=anchor aria-hidden=true href=#验证>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker buildx version
</span></span><span style=display:flex><span><span style=color:#6272a4># 输出示例：github.com/docker/buildx v0.11.2-desktop.1 986ab6afe790e25f022969a18bc0111cff170bc2</span>
</span></span></code></pre></div><h3 id=多架构镜像构建>多架构镜像构建<a hidden class=anchor aria-hidden=true href=#多架构镜像构建>#</a></h3><h4 id=构建器-builder>构建器 builder<a hidden class=anchor aria-hidden=true href=#构建器-builder>#</a></h4><p><code>docker buildx</code> 通过 <code>builder</code> 实例对象来管理构建配置和节点，命令行将构建任务发送至 <code>builder</code> 实例，再由 builder
指派给符合条件的节点执行。</p><p>我们可以基于同一个 docker 服务程序创建多个 builder 实例，提供给不同的项目使用以隔离各个项目的配置。</p><ul><li><strong>查看构建器列表</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker buildx ls
</span></span><span style=display:flex><span><span style=color:#6272a4># 在结果列表中可以看到目前使用的构建器及其支持的架构，如果目前使用的构建器支持我们需要的架构，则不需要创建新的构建器</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 示例</span>
</span></span><span style=display:flex><span>mybuilder *  docker-container
</span></span><span style=display:flex><span>  mybuilder0 unix:///var/run/docker.sock running linux/arm64, linux/amd64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6
</span></span><span style=display:flex><span>default      docker
</span></span><span style=display:flex><span>  default    default                     running linux/amd64, linux/386
</span></span></code></pre></div><ul><li><strong>创建新的构建器</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker buildx create --use --name mybuilder
</span></span></code></pre></div><ul><li><strong>检查和启动</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker buildx inspect mybuilder --bootstrap
</span></span></code></pre></div><h4 id=镜像构建>镜像构建<a hidden class=anchor aria-hidden=true href=#镜像构建>#</a></h4><ul><li>Dockerfile 示例</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#ff79c6>FROM</span><span style=color:#f1fa8c> nginx:latest</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>CMD</span> [<span style=color:#f1fa8c>&#34;nginx&#34;</span>, <span style=color:#f1fa8c>&#34;-g&#34;</span>, <span style=color:#f1fa8c>&#34;daemon off;&#34;</span>]
</span></span></code></pre></div><ul><li>进入 Dockerfile 所在目录，执行如下示例的命令，就可以构建自己指定的架构版本镜像并推送到当前用户的dockerhub 镜像仓库。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7 -t yanhuan6252/nginx:v1 --push .
</span></span></code></pre></div><ul><li>构建结果示例</li></ul><p><img alt="docker buildx res" loading=lazy src=/img/docker-buildx-res.png></p><h3 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h3><ul><li><code>buildx</code> 通过 <code>QEMU</code> 和 <code>binfmt_misc</code> 分别为 不同的 CPU 架构构建不同的镜像。构建完成后，就会创建一个 <code>manifest list</code>
，其中包含了指向这几个镜像的指针，当在不同的架构环境使用时会根据其环境拉取相应架构的镜像。</li></ul><h3 id=缺点>缺点<a hidden class=anchor aria-hidden=true href=#缺点>#</a></h3><ul><li>构建速度比较慢，效率比较低。</li><li>只能推送到镜像仓库后在查看和使用，没办法构建到本地。</li><li>没办法构建复杂镜像，比如说 MySQL 这种，安装时要 copy 不同架构的 rpm 包到镜像中，用这种方法就实现不了，还是得使用两个
Dockerfile 分别构建镜像，然后再合并<code>manifest list</code> 的方法来实现。</li><li>更适合个人/小团队开发测试使用，企业级使用的话最好还是使用内部流水线或者 github action 这种自动化程度更高的工具来完成。</li></ul><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://github.com/docker/buildx>buildx</a></li><li><a href=https://github.com/moby/buildkit>buildkit</a></li><li><a href=https://docs.docker.com/engine/reference/commandline/buildx_build/>buildx build</a></li><li><a href=https://zh.wikipedia.org/zh-hans/QEMU>QEMU</a></li><li><a href=https://zh.wikipedia.org/wiki/Binfmt_misc>binfmt_misc</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yanhuan0802.github.io/tags/docker/>Docker</a></li><li><a href=https://yanhuan0802.github.io/tags/arm/>ARM</a></li><li><a href=https://yanhuan0802.github.io/tags/x86/>X86</a></li></ul><nav class=paginav><a class=next href=https://yanhuan0802.github.io/posts/go-context/><span class=title>Next »</span><br><span>Go Context 那些事儿</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 跨平台构建多 CPU 架构容器镜像 on x" href="https://x.com/intent/tweet/?text=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%9e%84%e5%bb%ba%e5%a4%9a%20CPU%20%e6%9e%b6%e6%9e%84%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fmulti-arch-images%2f&amp;hashtags=Docker%2cARM%2cx86"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 跨平台构建多 CPU 架构容器镜像 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fmulti-arch-images%2f&amp;title=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%9e%84%e5%bb%ba%e5%a4%9a%20CPU%20%e6%9e%b6%e6%9e%84%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f&amp;summary=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%9e%84%e5%bb%ba%e5%a4%9a%20CPU%20%e6%9e%b6%e6%9e%84%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f&amp;source=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fmulti-arch-images%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 跨平台构建多 CPU 架构容器镜像 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fmulti-arch-images%2f&title=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%9e%84%e5%bb%ba%e5%a4%9a%20CPU%20%e6%9e%b6%e6%9e%84%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 跨平台构建多 CPU 架构容器镜像 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fmulti-arch-images%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 跨平台构建多 CPU 架构容器镜像 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%9e%84%e5%bb%ba%e5%a4%9a%20CPU%20%e6%9e%b6%e6%9e%84%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f%20-%20https%3a%2f%2fyanhuan0802.github.io%2fposts%2fmulti-arch-images%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 跨平台构建多 CPU 架构容器镜像 on telegram" href="https://telegram.me/share/url?text=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%9e%84%e5%bb%ba%e5%a4%9a%20CPU%20%e6%9e%b6%e6%9e%84%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f&amp;url=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fmulti-arch-images%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 跨平台构建多 CPU 架构容器镜像 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%9e%84%e5%bb%ba%e5%a4%9a%20CPU%20%e6%9e%b6%e6%9e%84%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f&u=https%3a%2f%2fyanhuan0802.github.io%2fposts%2fmulti-arch-images%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=yanhuan0802/yanhuan0802.github.io data-repo-id=R_kgDOIDpgTQ data-category=Announcements data-category-id=DIC_kwDOIDpgTc4CSYzO data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://yanhuan0802.github.io/>YanHuan's World</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>